import streamlit as st
import yfinance as yf
import pandas as pd
import plotly.graph_objects as go
from datetime import datetime, timedelta
import numpy as np
import re
import os
import hashlib
import itertools
import warnings

# 警告を非表示にする
warnings.filterwarnings('ignore', category=FutureWarning, module='yfinance')

# --- ユーザー認証設定 ---
USERS = {
    "admin": "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8",  # "password"
    "user1": "fcf730b6d95236ecd3c9fc2d92d7b6b2bb061514961aec041d6c7a7192f592e4",  # "secret123"
    "demo": "2a97516c354b68848cdbd8f54a226a0a55b21ed138e207ad6c5cbb9c00aa5aea",   # "demo"
    "eddy80524": "15e2b0d3c33891ebb0f1ef609ec419420c20e320ce94c65fbc8c3312448eb225",  # "123456789"
    "aoto7043": "15e2b0d3c33891ebb0f1ef609ec419420c20e320ce94c65fbc8c3312448eb225",   # "123456789"
    "yu-ado43": "15e2b0d3c33891ebb0f1ef609ec419420c20e320ce94c65fbc8c3312448eb225",   # "123456789"
    "seita": "15e2b0d3c33891ebb0f1ef609ec419420c20e320ce94c65fbc8c3312448eb225",      # "123456789"
    "yiuka3555": "15e2b0d3c33891ebb0f1ef609ec419420c20e320ce94c65fbc8c3312448eb225",   # "123456789"
}

# 初回ログインパスワードのハッシュ
INITIAL_PASSWORD_HASH = "15e2b0d3c33891ebb0f1ef609ec419420c20e320ce94c65fbc8c3312448eb225"  # "123456789"

def load_user_data():
    """ユーザーデータをファイルから読み込み"""
    user_file = "user_data.txt"
    if os.path.exists(user_file):
        users = {}
        with open(user_file, 'r', encoding='utf-8') as f:
            for line in f:
                if ':' in line:
                    username, password_hash = line.strip().split(':', 1)
                    users[username] = password_hash
        return users
    return USERS.copy()

def save_user_data(users):
    """ユーザーデータをファイルに保存"""
    user_file = "user_data.txt"
    with open(user_file, 'w', encoding='utf-8') as f:
        for username, password_hash in users.items():
            f.write(f"{username}:{password_hash}\n")

def update_password(username, new_password):
    """パスワードを更新"""
    users = load_user_data()
    users[username] = hash_password(new_password)
    save_user_data(users)
    return True

def is_initial_password(username, password):
    """初回ログインパスワードかどうかチェック"""
    return hash_password(password) == INITIAL_PASSWORD_HASH

def hash_password(password):
    """パスワードをSHA256でハッシュ化"""
    return hashlib.sha256(password.encode()).hexdigest()

def check_login(username, password):
    """ユーザー認証"""
    users = load_user_data()
    if username in users:
        return users[username] == hash_password(password)
    return False

def login_page():
    """ログインページ"""
    # サイドバーを非表示にする
    st.markdown("""
    <style>
    .css-1d391kg {display: none}
    .st-emotion-cache-1cypcdb {display: none}
    .st-emotion-cache-1gwvy71 {display: none}
    [data-testid="stSidebar"] {display: none}
    </style>
    """, unsafe_allow_html=True)
    
    st.title("🔐 株式分析ダッシュボード - ログイン")
    
    # パスワード変更が必要かチェック
    if 'password_change_required' in st.session_state and st.session_state.password_change_required:
        st.warning("⚠️ 初回ログインです。セキュリティのためパスワードを変更してください。")
        
        with st.form("password_change_form"):
            st.write("### パスワード変更")
            new_password = st.text_input("新しいパスワード", type="password")
            confirm_password = st.text_input("パスワード確認", type="password")
            
            col1, col2, col3 = st.columns([1, 1, 2])
            with col2:
                change_button = st.form_submit_button("パスワード変更", use_container_width=True)
            
            if change_button:
                if new_password != confirm_password:
                    st.error("❌ パスワードが一致しません。")
                elif len(new_password) < 6:
                    st.error("❌ パスワードは6文字以上で設定してください。")
                elif new_password == "123456789":
                    st.error("❌ 初期パスワードと同じパスワードは設定できません。")
                else:
                    if update_password(st.session_state.temp_username, new_password):
                        st.success("✅ パスワードが正常に変更されました！")
                        st.session_state.authenticated = True
                        st.session_state.username = st.session_state.temp_username
                        st.session_state.password_change_required = False
                        if 'temp_username' in st.session_state:
                            del st.session_state.temp_username
                        st.rerun()
                    else:
                        st.error("❌ パスワードの変更に失敗しました。")
        return
    
    # 通常のログインフォーム
    with st.form("login_form"):
        st.write("### ログイン情報を入力してください")
        username = st.text_input("ユーザー名")
        password = st.text_input("パスワード", type="password")
        
        col1, col2, col3 = st.columns([1, 1, 2])
        with col2:
            submit_button = st.form_submit_button("ログイン", use_container_width=True)
        
        if submit_button:
            if check_login(username, password):
                # 初回ログインパスワードかチェック
                if is_initial_password(username, password):
                    st.session_state.password_change_required = True
                    st.session_state.temp_username = username
                    st.info("🔑 初回ログインが検出されました。パスワードを変更してください。")
                    st.rerun()
                else:
                    st.session_state.authenticated = True
                    st.session_state.username = username
                    st.success("✅ ログインに成功しました！")
                    st.rerun()
            else:
                st.error("❌ ユーザー名またはパスワードが正しくありません。")

def password_change_page():
    """パスワード変更ページ"""
    st.title("🔑 パスワード変更")
    
    with st.form("password_change_form"):
        st.write("### 新しいパスワードを設定")
        current_password = st.text_input("現在のパスワード", type="password")
        new_password = st.text_input("新しいパスワード", type="password")
        confirm_password = st.text_input("パスワード確認", type="password")
        
        col1, col2, col3 = st.columns([1, 1, 2])
        with col2:
            change_button = st.form_submit_button("パスワード変更", use_container_width=True)
        
        if change_button:
            # 現在のパスワードをチェック
            if not check_login(st.session_state.username, current_password):
                st.error("❌ 現在のパスワードが正しくありません。")
            elif new_password != confirm_password:
                st.error("❌ 新しいパスワードが一致しません。")
            elif len(new_password) < 6:
                st.error("❌ パスワードは6文字以上で設定してください。")
            elif new_password == current_password:
                st.error("❌ 現在のパスワードと同じパスワードは設定できません。")
            else:
                if update_password(st.session_state.username, new_password):
                    st.success("✅ パスワードが正常に変更されました！")
                    st.info("次回ログイン時から新しいパスワードをご利用ください。")
                else:
                    st.error("❌ パスワードの変更に失敗しました。")
    
    # ダッシュボードに戻るボタン
    st.write("---")
    if st.button("🏠 ダッシュボードに戻る", type="primary"):
        st.session_state.page = 'dashboard'
        st.rerun()

def logout():
    """ログアウト処理"""
    st.session_state.authenticated = False
    st.session_state.username = None
    if 'page' in st.session_state:
        st.session_state.page = 'dashboard'
    st.rerun()

# --- ページ設定 ---
st.set_page_config(
    page_title="統合株式分析ダッシュボード",
    page_icon="📈",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- セッション状態の初期化 ---
if 'authenticated' not in st.session_state:
    st.session_state.authenticated = False
if 'username' not in st.session_state:
    st.session_state.username = None
if 'page' not in st.session_state:
    st.session_state.page = 'dashboard'
if 'selected_ticker' not in st.session_state:
    st.session_state.selected_ticker = None

# --- 日本企業名マッピング ---
JAPANESE_COMPANY_NAMES = {
    '6357.T': '三精テクノロジーズ',
    '4816.T': '東映アニメーション',
    '2991.T': 'ランドネット',
    '7564.T': 'ワークマン',
    '7711.T': '助川電気工業',
    '6405.T': '鈴茂器工',
    '2428.T': 'ウェルネット',
    '6231.T': '木村工機',
    '6855.T': '日本電子材料',
    '4832.T': 'JFEシステムズ',
    '4767.T': 'テー・オー・ダブリュー',
    # 既存の大型株
    '1308.T': 'TOPIXコア30連動型ETF',
    '6758.T': 'ソニーグループ',
    '7203.T': 'トヨタ自動車',
    '6861.T': 'キーエンス',
    '4568.T': '第一三共',
    '8035.T': '東京エレクトロン',
    '8306.T': '三菱UFJフィナンシャル・グループ',
    '9983.T': 'ファーストリテイリング',
    '6752.T': 'パナソニック',
}

# TICKER_NAMESとしても使用可能
TICKER_NAMES = JAPANESE_COMPANY_NAMES

# --- 三精テクノロジーズ業績予想修正履歴データ ---
FORECAST_TEXT_6357 = """
FY 2026.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2025/05/09 決70.000
-
5.000
-
5.300
-
-
3.200
-
171.410
-
60.000
-
2025/08/07 決70.000
→
5.000
→
5.300
→
-
3.200
→
171.410
→
60.000
→
FY 2025.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2024/05/09 決64.000
-
5.100
-
5.400
-
-
3.300
-
177.480
-
50.000
-
2024/08/08 決64.000
→
5.100
→
5.400
→
-
3.300
→
177.480
→
50.000
→
2024/11/14 決64.000
→
5.100
→
5.400
→
-
3.300
→
177.480
→
50.000
→
2025/02/13 決64.000
→
5.100
→
5.400
→
-
3.300
→
177.480
→
50.000
→
2025/05/09 実61.862
↓(-2.138)
4.797
↓(-0.303)
5.294
↓(-0.106)
5.300
-
2.995
↓(-0.305)
160.450
↓(-17.030)
55.000
↑(+5.000)
Delta from Initial Guidance↓(-2.138)
↓(-0.303)
↓(-0.106)
-
↓(-0.305)
↓(-17.030)
↑(+5.000)
FY 2024.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2023/05/11 決47.000
-
2.900
-
2.900
-
-
2.000
-
107.760
-
40.000
-
2023/08/10 決47.000
→
2.900
→
2.900
→
-
2.000
→
107.760
→
40.000
→
2023/11/09 決47.000
→
2.900
→
2.900
→
-
2.000
→
107.760
→
40.000
→
2024/02/08 決47.000
→
2.900
→
2.900
→
-
2.000
→
107.760
→
40.000
→
2024/05/09 実52.307
↑(+5.307)
3.156
↑(+0.256)
3.597
↑(+0.697)
3.585
-
2.072
↑(+0.072)
111.450
↑(+3.690)
40.000
→
Delta from Initial Guidance↑(+5.307)
↑(+0.256)
↑(+0.697)
-
↑(+0.072)
↑(+3.690)
→
FY 2023.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2022/05/13 決40.500
-
2.000
-
2.000
-
-
1.500
-
81.060
-
35.000
-
2022/08/04 決40.500
→
2.000
→
2.000
→
-
1.500
→
81.060
→
35.000
→
2022/11/10 決40.500
→
2.000
→
2.000
→
-
1.500
→
81.060
→
35.000
→
2023/02/09 決40.500
→
2.000
→
2.000
→
-
1.500
→
81.060
→
35.000
→
2023/05/11 実40.684
↑(+0.184)
2.007
↑(+0.007)
2.758
↑(+0.758)
2.758
-
1.704
↑(+0.204)
91.890
↑(+10.830)
37.500
↑(+2.500)
Delta from Initial Guidance↑(+0.184)
↑(+0.007)
↑(+0.758)
-
↑(+0.204)
↑(+10.830)
↑(+2.500)
FY 2022.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2021/05/14 決36.000
-
1.500
-
2.000
-
-
1.100
-
59.470
-
35.000
-
2021/08/05 決36.000
→
1.500
→
2.000
→
-
1.100
→
59.470
→
35.000
→
2021/11/11 決36.000
→
1.500
→
2.000
→
-
1.100
→
59.470
→
35.000
→
2022/02/10 決36.000
→
1.500
→
2.000
→
-
1.100
→
59.470
→
35.000
→
2022/05/13 実34.404
↓(-1.596)
1.040
↓(-0.460)
1.881
↓(-0.119)
2.541
-
1.449
↑(+0.349)
78.290
↑(+18.820)
35.000
→
Delta from Initial Guidance↓(-1.596)
↓(-0.460)
↓(-0.119)
-
↑(+0.349)
↑(+18.820)
→
FY 2021.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2020/11/12 決37.000
-
0.540
-
0.540
-
-
-0.240
-
-12.980
-
30.000
-
2021/02/10 決37.000
→
0.540
→
0.540
→
-
-0.240
→
-12.980
→
30.000
→
2021/04/28 修36.500
↓(-0.500)
1.400
↑(+0.860)
1.500
↑(+0.960)
-
0.700
↑(+0.940)
37.850
↑(+50.830)
-
2021/05/14 実36.538
↑(+0.038)
1.423
↑(+0.023)
1.544
↑(+0.044)
1.544
-
0.751
↑(+0.051)
40.620
↑(+2.770)
35.000
-
Delta from Initial Guidance↓(-0.462)
↑(+0.883)
↑(+1.004)
-
↑(+0.991)
↑(+53.600)
↑(+5.000)
FY 2020.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2019/11/14 決50.000
-
3.300
-
3.200
-
-
1.250
-
67.740
-
35.000
-
2020/02/13 決50.000
→
3.300
→
3.200
→
-
1.250
→
67.740
→
35.000
→
2020/05/15 実45.078
↓(-4.922)
2.872
↓(-0.428)
2.890
↓(-0.310)
2.602
-
1.421
↑(+0.171)
76.950
↑(+9.210)
35.000
→
Delta from Initial Guidance↓(-4.922)
↓(-0.428)
↓(-0.310)
-
↑(+0.171)
↑(+9.210)
→
"""

# --- 東映アニメーション業績予想修正履歴データ ---
FORECAST_TEXT_4816 = """
FY 2026.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2025/05/16 決88.000
-
26.000
-
26.700
-
-
19.100
-
93.400
-
41.000
-
2025/07/30 決88.000
→
26.000
→
26.700
→
-
19.100
→
93.400
→
41.000
→
FY 2025.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2024/05/13 決82.000
-
20.000
-
20.500
-
-
15.000
-
73.360
-
31.000
-
2024/07/31 決82.000
→
20.000
→
20.500
→
-
15.000
→
73.360
→
31.000
→
2024/10/28 修90.000
↑(+8.000)
27.000
↑(+7.000)
27.500
↑(+7.000)
-
19.500
↑(+4.500)
95.360
↑(+22.000)
-
2024/10/30 決90.000
→
27.000
→
27.500
→
-
19.500
→
95.360
→
31.000
-
2025/01/30 決90.000
→
27.000
→
27.500
→
-
19.500
→
95.360
→
31.000
→
2025/05/14 修100.800
↑(+10.800)
32.400
↑(+5.400)
33.100
↑(+5.600)
-
23.600
↑(+4.100)
115.410
↑(+20.050)
-
2025/05/16 実100.836
↑(+0.036)
32.432
↑(+0.032)
33.188
↑(+0.088)
32.809
-
23.623
↑(+0.023)
115.520
↑(+0.110)
41.000
-
Delta from Initial Guidance↑(+18.836)
↑(+12.432)
↑(+12.688)
-
↑(+8.623)
↑(+42.160)
↑(+10.000)
FY 2024.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2023/05/11 決72.000
-
17.500
-
17.800
-
-
12.000
-
293.490
-
90.000
-
2023/07/28 決72.000
→
17.500
→
17.800
→
-
12.000
→
293.490
→
90.000
→
2023/10/24 修82.000
↑(+10.000)
19.000
↑(+1.500)
20.000
↑(+2.200)
-
13.500
↑(+1.500)
330.130
↑(+36.640)
-
2023/10/27 決82.000
→
19.000
→
20.000
→
-
13.500
→
330.130
→
90.000
-
2024/01/29 決83.000
↑(+1.000)
20.500
↑(+1.500)
21.500
↑(+1.500)
-
15.500
↑(+2.000)
379.040
↑(+48.910)
114.000
↑(+24.000)
2024/05/13 実88.654
↑(+5.654)
23.364
↑(+2.864)
26.453
↑(+4.953)
26.707
-
18.795
↑(+3.295)
91.930
↓(-287.110)
155.000
↑(+41.000)
Delta from Initial Guidance↑(+16.654)
↑(+5.864)
↑(+8.653)
-
↑(+6.795)
↓(-201.560)
↑(+65.000)
FY 2023.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2022/05/12 決70.000
-
18.300
-
18.900
-
-
13.500
-
330.080
-
99.000
-
2022/07/28 決70.000
→
18.300
→
18.900
→
-
13.500
→
330.080
→
99.000
→
2022/10/21 修76.000
↑(+6.000)
23.500
↑(+5.200)
25.000
↑(+6.100)
-
18.000
↑(+4.500)
440.150
↑(+110.070)
-
2022/10/27 決76.000
→
23.500
→
25.000
→
-
18.000
→
440.150
→
99.000
-
2023/01/30 決76.000
→
23.500
→
25.000
→
-
18.000
→
440.150
→
99.000
→
2023/04/25 修87.400
↑(+11.400)
28.600
↑(+5.100)
29.700
↑(+4.700)
-
20.900
↑(+2.900)
511.110
↑(+70.960)
-
2023/05/11 実87.457
↑(+0.057)
28.669
↑(+0.069)
29.791
↑(+0.091)
29.791
-
20.900
→
102.220
↓(-408.890)
155.000
-
Delta from Initial Guidance↑(+17.457)
↑(+10.369)
↑(+10.891)
-
↑(+7.400)
↓(-227.860)
↑(+56.000)
"""

# --- ランドネット業績予想修正履歴データ ---
FORECAST_TEXT_2991 = """
FY 2025.07売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2024/09/09 決96.241
-
3.262
-
2.821
-
-
1.881
-
314.940
-
31.500
-
2024/10/15 修-
-
-
-
-
-
15.750
↓(-15.750)
2024/12/09 決96.241
-
3.262
-
2.821
-
-
1.881
-
157.470
-
15.750
→
2025/03/10 決98.241
↑(+2.000)
3.847
↑(+0.585)
3.437
↑(+0.616)
-
2.332
↑(+0.451)
195.130
↑(+37.660)
19.550
↑(+3.800)
2025/06/09 決98.241
→
3.847
→
3.437
→
-
2.332
→
195.130
→
19.550
→
FY 2024.07売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2023/09/08 決73.857
-
1.794
-
1.565
-
-
1.044
-
175.420
-
18.500
-
2023/12/08 決73.857
→
1.794
→
1.565
→
-
1.044
→
175.420
→
18.500
→
2024/03/08 決73.857
→
1.794
→
1.565
→
-
1.044
→
175.420
→
18.500
→
2024/06/07 決73.857
→
1.794
→
1.565
→
-
1.044
→
175.420
→
18.500
→
2024/07/26 修75.880
↑(+2.023)
2.408
↑(+0.614)
2.133
↑(+0.568)
-
1.520
↑(+0.476)
254.430
↑(+79.010)
25.500
↑(+7.000)
2024/09/09 実77.791
↑(+1.911)
2.786
↑(+0.378)
2.519
↑(+0.386)
2.753
-
1.840
↑(+0.320)
308.830
↑(+54.400)
30.750
↑(+5.250)
Delta from Initial Guidance↑(+3.934)
↑(+0.992)
↑(+0.954)
-
↑(+0.796)
↑(+133.410)
↑(+12.250)
FY 2023.07売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2022/09/09 決60.099
-
1.869
-
1.704
-
-
1.097
-
369.800
-
37.000
-
2022/11/14 修-
-
-
-
-
-
18.500
↓(-18.500)
2022/12/12 決60.099
-
1.869
-
1.704
-
-
1.097
-
184.900
-
18.500
→
2023/03/10 決60.099
→
1.869
→
1.704
→
-
1.097
→
184.450
↓(-0.450)
18.500
→
2023/06/09 決60.099
→
1.869
→
1.704
→
-
1.097
→
184.450
→
18.500
→
2023/09/08 実63.648
↑(+3.549)
1.521
↓(-0.348)
1.362
↓(-0.342)
1.478
-
0.988
↓(-0.109)
166.090
↓(-18.360)
18.500
→
Delta from Initial Guidance↑(+3.549)
↓(-0.348)
↓(-0.342)
-
↓(-0.109)
↓(-203.710)
↓(-18.500)
FY 2022.07売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2021/09/10 決48.721
-
1.502
-
1.405
-
-
0.969
-
654.530
-
51.500
-
2021/12/10 決48.721
→
1.502
→
1.405
→
-
0.969
→
654.530
→
51.500
→
2022/03/11 決48.721
→
1.502
→
1.405
→
-
0.969
→
654.530
→
51.500
→
2022/05/16 修-
-
-
-
-
-
25.750
↓(-25.750)
2022/06/10 決48.721
-
1.502
-
1.405
-
-
0.969
-
327.270
-
25.750
→
2022/09/09 実51.871
↑(+3.150)
1.505
↑(+0.003)
1.389
↓(-0.016)
1.433
-
0.956
↓(-0.013)
161.110
↓(-166.160)
32.250
↑(+6.500)
Delta from Initial Guidance↑(+3.150)
↑(+0.003)
↓(-0.016)
-
↓(-0.013)
↓(-493.420)
↓(-19.250)
"""

# --- ワークマン業績予想修正履歴データ ---
FORECAST_TEXT_7564 = """
FY 2026.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2025/05/12 決147.152
-
26.005
-
26.760
-
-
18.100
-
221.790
-
73.000
-
2025/08/04 決147.152
→
26.005
→
26.760
→
-
18.100
→
221.790
→
73.000
→
FY 2025.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2024/05/07 決138.564
-
23.632
-
24.167
-
-
16.325
-
200.040
-
68.000
-
2024/08/05 決138.564
→
23.632
→
24.167
→
-
16.325
→
200.040
→
68.000
→
2024/11/05 決138.564
→
23.632
→
24.167
→
-
16.325
→
200.040
→
68.000
→
2025/02/10 決138.564
→
23.632
→
24.167
→
-
16.325
→
200.040
→
68.000
→
2025/05/12 実136.933
↓(-1.631)
24.394
↑(+0.762)
24.904
↑(+0.737)
24.890
-
16.892
↑(+0.567)
206.990
↑(+6.950)
73.000
↑(+5.000)
Delta from Initial Guidance↓(-1.631)
↑(+0.762)
↑(+0.737)
-
↑(+0.567)
↑(+6.950)
↑(+5.000)
FY 2024.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2023/05/08 決136.576
-
25.720
-
26.214
-
-
17.563
-
215.210
-
68.000
-
2023/08/07 決136.576
→
25.720
→
26.214
→
-
17.563
→
215.210
→
68.000
→
2023/11/06 決136.576
→
25.720
→
26.214
→
-
17.563
→
215.210
→
68.000
→
2024/02/05 決134.993
↓(-1.583)
23.440
↓(-2.280)
23.955
↓(-2.259)
-
16.030
↓(-1.533)
196.420
↓(-18.790)
68.000
→
2024/05/07 実132.651
↓(-2.342)
23.142
↓(-0.298)
23.666
↓(-0.289)
23.636
-
15.986
↓(-0.044)
195.880
↓(-0.540)
68.000
→
Delta from Initial Guidance↓(-3.925)
↓(-2.578)
↓(-2.548)
-
↓(-1.577)
↓(-19.330)
→
FY 2023.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2022/05/09 決124.110
-
24.461
-
25.063
-
-
16.782
-
205.650
-
68.000
-
2022/08/08 決124.110
→
24.461
→
25.063
→
-
16.782
→
205.650
→
68.000
→
2022/11/07 決125.213
↑(+1.103)
21.774
↓(-2.687)
22.355
↓(-2.708)
-
14.897
↓(-1.885)
182.550
↓(-23.100)
68.000
→
2023/02/06 決125.213
→
21.774
→
22.355
→
-
14.897
→
182.550
→
68.000
→
2023/05/08 実128.289
↑(+3.076)
24.106
↑(+2.332)
24.664
↑(+2.309)
24.655
-
16.656
↑(+1.759)
204.100
↑(+21.550)
68.000
→
Delta from Initial Guidance↑(+4.179)
↓(-0.355)
↓(-0.399)
-
↓(-0.126)
↓(-1.550)
→
FY 2022.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2021/05/10 決114.445
-
26.673
-
27.200
-
-
18.155
-
222.460
-
64.000
-
2021/08/10 決114.445
→
26.673
→
27.200
→
-
18.155
→
222.460
→
64.000
→
2021/11/08 決114.445
→
26.673
→
27.200
→
-
18.155
→
222.460
→
64.000
→
2022/02/07 決114.445
→
26.673
→
27.200
→
-
18.155
→
222.460
→
64.000
→
2022/05/09 実116.264
↑(+1.819)
26.802
↑(+0.129)
27.395
↑(+0.195)
27.313
-
18.303
↑(+0.148)
224.280
↑(+1.820)
68.000
↑(+4.000)
Delta from Initial Guidance↑(+1.819)
↑(+0.129)
↑(+0.195)
-
↑(+0.148)
↑(+1.820)
↑(+4.000)
FY 2021.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2020/08/11 決99.009
-
21.847
-
23.343
-
-
15.539
-
190.410
-
50.000
-
2020/11/09 決99.009
→
21.847
→
23.343
→
-
15.539
→
190.410
→
50.000
→
2021/02/08 決99.009
→
21.847
→
23.343
→
-
15.539
→
190.410
→
50.000
→
2021/05/10 実105.815
↑(+6.806)
23.955
↑(+2.108)
25.409
↑(+2.066)
25.356
-
17.039
↑(+1.500)
208.800
↑(+18.390)
64.000
↑(+14.000)
Delta from Initial Guidance↑(+6.806)
↑(+2.108)
↑(+2.066)
-
↑(+1.500)
↑(+18.390)
↑(+14.000)
"""

# --- 助川電気工業業績予想修正履歴データ ---
FORECAST_TEXT_7711 = """
FY 2025.09売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2024/11/07 決5.060
-
0.836
-
0.843
-
-
0.590
-
106.980
-
36.000
-
2024/12/06 決5.060
→
0.836
→
0.843
→
-
0.590
→
106.980
→
36.000
→
2025/02/06 決5.060
→
0.836
→
0.843
→
-
0.590
→
106.980
→
36.000
→
2025/05/08 決5.480
↑(+0.420)
1.020
↑(+0.184)
1.029
↑(+0.186)
-
0.724
↑(+0.134)
131.280
↑(+24.300)
38.000
↑(+2.000)
2025/08/07 決5.700
↑(+0.220)
1.210
↑(+0.190)
1.224
↑(+0.195)
-
0.829
↑(+0.105)
150.320
↑(+19.040)
40.000
↑(+2.000)
FY 2024.09売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2023/11/09 決4.590
-
0.514
-
0.519
-
-
0.363
-
65.820
-
30.000
-
2024/02/08 決4.779
↑(+0.189)
0.650
↑(+0.136)
0.652
↑(+0.133)
-
0.456
↑(+0.093)
82.680
↑(+16.860)
30.000
→
2024/05/09 決4.779
→
0.725
↑(+0.075)
0.731
↑(+0.079)
-
0.517
↑(+0.061)
93.750
↑(+11.070)
31.000
↑(+1.000)
2024/08/08 決4.779
→
0.789
↑(+0.064)
0.797
↑(+0.066)
-
0.565
↑(+0.048)
102.450
↑(+8.700)
32.000
↑(+1.000)
2024/11/07 実4.965
↑(+0.186)
0.916
↑(+0.127)
0.917
↑(+0.120)
0.893
-
0.637
↑(+0.072)
115.680
↑(+13.230)
34.000
↑(+2.000)
Delta from Initial Guidance↑(+0.375)
↑(+0.402)
↑(+0.398)
-
↑(+0.274)
↑(+49.860)
↑(+4.000)
FY 2023.09売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2022/11/10 決4.539
-
0.479
-
0.472
-
-
0.293
-
49.930
-
28.000
-
2023/02/09 決4.539
→
0.479
→
0.472
→
-
0.293
→
49.930
→
28.000
→
2023/05/11 決4.539
→
0.479
→
0.472
→
-
0.293
→
52.570
↑(+2.640)
28.000
→
2023/08/09 決4.549
↑(+0.010)
0.517
↑(+0.038)
0.525
↑(+0.053)
-
0.344
↑(+0.051)
61.720
↑(+9.150)
29.000
↑(+1.000)
2023/11/09 実4.577
↑(+0.028)
0.590
↑(+0.073)
0.597
↑(+0.072)
0.564
-
0.397
↑(+0.053)
71.370
↑(+9.650)
29.000
→
Delta from Initial Guidance↑(+0.038)
↑(+0.111)
↑(+0.125)
-
↑(+0.104)
↑(+21.440)
↑(+1.000)
FY 2022.09売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2021/11/11 決4.222
-
0.363
-
0.365
-
-
0.252
-
42.940
-
26.000
-
2022/02/08 決4.539
↑(+0.317)
0.472
↑(+0.109)
0.474
↑(+0.109)
-
0.321
↑(+0.069)
54.700
↑(+11.760)
26.000
→
2022/05/10 決4.539
→
0.472
→
0.474
→
-
0.321
→
54.700
→
26.000
→
2022/08/09 決4.539
→
0.472
→
0.474
→
-
0.321
→
54.700
→
26.000
→
2022/11/10 実4.332
↓(-0.207)
0.445
↓(-0.027)
0.469
↓(-0.005)
0.469
-
0.325
↑(+0.004)
55.460
↑(+0.760)
27.000
↑(+1.000)
Delta from Initial Guidance↑(+0.110)
↑(+0.082)
↑(+0.104)
-
↑(+0.073)
↑(+12.520)
↑(+1.000)
FY 2021.09売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2020/11/10 決3.574
-
0.093
-
0.094
-
-
0.060
-
10.220
-
24.000
-
2021/02/09 決3.574
→
0.093
→
0.094
→
-
0.060
→
10.220
→
24.000
→
2021/04/28 修3.622
↑(+0.048)
0.219
↑(+0.126)
0.221
↑(+0.127)
-
0.177
↑(+0.117)
30.160
↑(+19.940)
-
2021/05/06 決3.622
→
0.219
→
0.221
→
-
0.177
→
30.160
→
24.000
-
2021/08/05 決3.622
→
0.219
→
0.221
→
-
0.177
→
30.160
→
24.000
→
2021/11/04 修3.698
↑(+0.076)
0.292
↑(+0.073)
0.288
↑(+0.067)
-
0.199
↑(+0.022)
33.910
↑(+3.750)
-
2021/11/11 実3.698
→
0.293
↑(+0.001)
0.289
↑(+0.001)
0.289
-
0.199
→
33.980
↑(+0.070)
24.000
-
Delta from Initial Guidance↑(+0.124)
↑(+0.200)
↑(+0.195)
-
↑(+0.139)
↑(+23.760)
→
"""

# --- 鈴茂器工業績予想修正履歴データ ---
FORECAST_TEXT_6405 = """
FY 2026.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2025/05/13 決17.870
-
2.000
-
2.045
-
-
1.495
-
115.540
-
35.000
-
2025/08/08 決17.870
→
2.000
→
2.045
→
-
1.495
→
115.540
→
35.000
→
FY 2025.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2024/05/13 決15.960
-
1.900
-
1.915
-
-
1.350
-
104.410
-
33.000
-
2024/06/18 決15.960
→
1.900
→
1.915
→
-
1.350
→
104.410
→
33.000
→
2024/08/09 決15.960
→
1.900
→
1.915
→
-
1.350
→
104.410
→
33.000
→
2024/11/14 決15.960
→
1.900
→
1.915
→
-
1.350
→
104.410
→
33.000
→
2025/02/14 決15.960
→
1.900
→
1.915
→
-
1.350
→
104.410
→
33.000
→
2025/05/13 実15.568
↓(-0.392)
1.890
↓(-0.010)
1.948
↑(+0.033)
1.970
-
1.463
↑(+0.113)
113.090
↑(+8.680)
34.000
↑(+1.000)
Delta from Initial Guidance↓(-0.392)
↓(-0.010)
↑(+0.033)
-
↑(+0.113)
↑(+8.680)
↑(+1.000)
FY 2024.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2023/05/12 決15.000
-
1.500
-
1.505
-
-
1.020
-
78.880
-
31.000
-
2023/08/10 決15.000
→
1.500
→
1.505
→
-
1.020
→
78.880
→
31.000
→
2024/02/14 決15.000
→
1.500
→
1.505
→
-
1.020
→
78.880
→
31.000
→
2024/05/13 実14.515
↓(-0.485)
1.475
↓(-0.025)
1.498
↓(-0.007)
1.545
-
1.141
↑(+0.121)
88.230
↑(+9.350)
32.000
↑(+1.000)
Delta from Initial Guidance↓(-0.485)
↓(-0.025)
↓(-0.007)
-
↑(+0.121)
↑(+9.350)
↑(+1.000)
FY 2023.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2022/05/13 決13.000
-
1.800
-
1.800
-
-
1.315
-
203.620
-
62.000
-
2022/06/07 修-
-
-
-
-
-
31.000
↓(-31.000)
2022/08/10 決13.000
-
1.800
-
1.800
-
-
1.315
-
101.810
-
31.000
→
2022/11/11 決13.000
→
1.800
→
1.800
→
-
1.315
→
101.810
→
31.000
→
2023/02/10 決13.390
↑(+0.390)
1.230
↓(-0.570)
1.150
↓(-0.650)
-
0.770
↓(-0.545)
59.600
↓(-42.210)
31.000
→
2023/05/12 実13.456
↑(+0.066)
1.204
↓(-0.026)
1.140
↓(-0.010)
1.236
-
0.826
↑(+0.056)
63.930
↑(+4.330)
31.000
→
Delta from Initial Guidance↑(+0.456)
↓(-0.596)
↓(-0.660)
-
↓(-0.489)
↓(-139.690)
↓(-31.000)
FY 2022.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2021/05/14 決10.000
-
0.930
-
0.930
-
-
0.630
-
97.760
-
20.000
-
2021/08/06 決10.000
→
0.930
→
0.930
→
-
0.630
→
97.760
→
20.000
→
2021/11/12 決10.000
→
0.930
→
0.930
→
-
0.630
→
97.760
→
20.000
→
2022/02/10 決11.770
↑(+1.770)
1.700
↑(+0.770)
1.710
↑(+0.780)
-
1.150
↑(+0.520)
178.300
↑(+80.540)
40.000
↑(+20.000)
2022/05/13 実11.566
↓(-0.204)
1.517
↓(-0.183)
1.544
↓(-0.166)
1.582
-
1.070
↓(-0.080)
82.960
↓(-95.340)
40.000
→
Delta from Initial Guidance↑(+1.566)
↑(+0.587)
↑(+0.614)
-
↑(+0.440)
↓(-14.800)
↑(+20.000)
FY 2021.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2020/05/15 決-
-
-
-
-
-
20.000
-
2020/08/07 決-
-
-
-
-
-
20.000
→
2020/09/11 修8.600
-
0.430
-
0.420
-
-
0.290
-
44.850
-
-
2020/11/13 決8.600
-
0.430
-
0.420
-
-
0.290
-
44.850
-
20.000
-
2021/02/10 修9.160
-
0.715
-
0.710
-
-
0.490
-
75.790
-
-
2021/02/10 決9.160
-
0.715
-
0.710
-
-
0.490
-
75.790
-
20.000
-
2021/05/11 修9.480
-
0.915
-
0.920
-
-
0.680
-
105.230
-
-
2021/05/14 実9.486
-
0.919
-
0.921
-
0.962
-
0.683
-
105.760
-
20.000
-
Delta from Initial Guidance-
-
-
-
-
-
→
"""

# --- ウェルネット業績予想修正履歴データ ---
FORECAST_TEXT_2428 = """
FY 2026.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2025/08/08 決11.500
-
1.680
-
1.700
-
-
1.100
-
58.550
-
29.500
-
FY 2025.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2024/08/14 決12.000
-
-
1.500
-
-
1.000
-
52.910
-
26.460
-
2024/10/30 決12.000
→
-
1.500
→
-
1.000
→
52.910
→
26.460
→
2025/01/31 決12.000
→
-
1.500
→
-
1.000
→
52.910
→
26.460
→
2025/02/14 決12.000
→
-
1.500
→
-
1.000
→
52.910
→
26.460
→
2025/04/30 決10.800
↓(-1.200)
-
1.600
↑(+0.100)
-
1.050
↑(+0.050)
56.000
↑(+3.090)
28.000
↑(+1.540)
2025/08/08 実10.919
↑(+0.119)
1.502
-
1.665
↑(+0.065)
1.596
-
1.077
↑(+0.027)
57.560
↑(+1.560)
29.000
↑(+1.000)
Delta from Initial Guidance↓(-1.081)
-
↑(+0.165)
-
↑(+0.077)
↑(+4.650)
↑(+2.540)
FY 2024.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2023/08/14 決10.160
-
-
1.150
-
-
0.790
-
41.860
-
21.000
-
2023/10/30 決10.160
→
-
1.150
→
-
0.790
→
41.860
→
21.000
→
2024/02/02 決10.160
→
-
1.150
→
-
0.790
→
41.860
→
21.000
→
2024/05/08 決10.160
→
-
1.150
→
-
0.790
→
41.860
→
21.000
→
2024/08/14 実10.132
↓(-0.028)
1.222
-
1.224
↑(+0.074)
1.224
-
0.836
↑(+0.046)
44.290
↑(+2.430)
22.150
↑(+1.150)
Delta from Initial Guidance↓(-0.028)
-
↑(+0.074)
-
↑(+0.046)
↑(+2.430)
↑(+1.150)
FY 2023.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2022/09/06 修9.300
-
-
0.860
-
-
0.600
-
31.830
-
16.000
-
2022/10/31 決9.300
→
-
0.860
→
-
0.600
→
31.830
→
16.000
→
2023/02/03 決9.300
→
-
0.860
→
-
0.600
→
31.830
→
16.000
→
2023/05/08 修9.400
↑(+0.100)
-
0.920
↑(+0.060)
-
0.620
↑(+0.020)
32.850
↑(+1.020)
16.430
↑(+0.430)
2023/05/08 決9.400
→
-
0.920
→
-
0.620
→
32.850
→
16.430
→
2023/08/14 実9.424
↑(+0.024)
0.939
-
0.936
↑(+0.016)
0.962
-
0.635
↑(+0.015)
33.680
↑(+0.830)
16.840
↑(+0.410)
Delta from Initial Guidance↑(+0.124)
-
↑(+0.076)
-
↑(+0.035)
↑(+1.850)
↑(+0.840)
"""

# --- 木村工機業績予想修正履歴データ ---
FORECAST_TEXT_6231 = """
FY 2026.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2025/05/14 決16.900
-
3.780
-
3.750
-
-
2.615
-
733.890
-
140.000
-
2025/08/08 決16.900
→
3.780
→
3.750
→
-
2.615
→
733.890
→
140.000
→
FY 2025.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2024/05/10 決15.000
-
3.110
-
3.115
-
-
2.105
-
588.510
-
90.000
-
2024/08/09 決15.000
→
3.110
→
3.115
→
-
2.105
→
588.510
→
90.000
→
2024/11/08 決15.000
→
3.110
→
3.115
→
-
2.105
→
588.510
→
90.000
→
2025/02/14 決15.500
↑(+0.500)
3.305
↑(+0.195)
3.285
↑(+0.170)
-
2.230
↑(+0.125)
624.450
↑(+35.940)
120.000
↑(+30.000)
2025/05/14 実16.042
↑(+0.542)
3.676
↑(+0.371)
3.660
↑(+0.375)
3.575
-
2.496
↑(+0.266)
699.000
↑(+74.550)
120.000
→
Delta from Initial Guidance↑(+1.042)
↑(+0.566)
↑(+0.545)
-
↑(+0.391)
↑(+110.490)
↑(+30.000)
FY 2024.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2023/05/12 決12.400
-
1.580
-
1.570
-
-
1.070
-
298.270
-
40.000
-
2023/08/08 決12.400
→
1.580
→
1.570
→
-
1.070
→
298.270
→
40.000
→
2023/11/10 決13.000
↑(+0.600)
2.430
↑(+0.850)
2.410
↑(+0.840)
-
1.690
↑(+0.620)
472.170
↑(+173.900)
65.000
↑(+25.000)
2024/02/09 決13.000
→
2.430
→
2.410
→
-
1.690
→
472.090
↓(-0.080)
65.000
→
2024/03/08 修13.800
↑(+0.800)
2.635
↑(+0.205)
2.640
↑(+0.230)
-
1.850
↑(+0.160)
516.780
↑(+44.690)
90.000
↑(+25.000)
2024/05/10 実13.853
↑(+0.053)
2.679
↑(+0.044)
2.683
↑(+0.043)
2.682
-
2.065
↑(+0.215)
576.990
↑(+60.210)
90.000
→
Delta from Initial Guidance↑(+1.453)
↑(+1.099)
↑(+1.113)
-
↑(+0.995)
↑(+278.720)
↑(+50.000)
FY 2023.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2022/05/13 決11.400
-
1.200
-
1.150
-
-
0.710
-
191.670
-
25.000
-
2022/08/10 決11.400
→
1.200
→
1.150
→
-
0.710
→
193.120
↑(+1.450)
25.000
→
2022/11/11 決11.400
→
1.200
→
1.150
→
-
0.710
→
195.190
↑(+2.070)
25.000
→
2023/02/10 決11.400
→
1.200
→
1.150
→
-
0.710
→
195.540
↑(+0.350)
25.000
→
2023/04/14 修11.700
↑(+0.300)
1.520
↑(+0.320)
1.510
↑(+0.360)
-
0.930
↑(+0.220)
256.130
↑(+60.590)
-
2023/05/12 実11.703
↑(+0.003)
1.573
↑(+0.053)
1.568
↑(+0.058)
1.427
-
1.037
↑(+0.107)
285.640
↑(+29.510)
40.000
-
Delta from Initial Guidance↑(+0.303)
↑(+0.373)
↑(+0.418)
-
↑(+0.327)
↑(+93.970)
↑(+15.000)
FY 2022.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2021/05/14 決11.000
-
1.390
-
1.355
-
-
0.900
-
237.750
-
25.000
-
2021/08/11 決11.000
→
1.390
→
1.355
→
-
0.900
→
239.050
↑(+1.300)
25.000
→
2021/11/12 決11.000
→
1.390
→
1.355
→
-
0.900
→
239.530
↑(+0.480)
25.000
→
2022/02/10 決11.000
→
1.390
→
1.355
→
-
0.900
→
239.770
↑(+0.240)
25.000
→
2022/05/13 実10.200
↓(-0.800)
1.089
↓(-0.301)
1.331
↓(-0.024)
1.294
-
0.877
↓(-0.023)
234.020
↓(-5.750)
25.000
→
Delta from Initial Guidance↓(-0.800)
↓(-0.301)
↓(-0.024)
-
↓(-0.023)
↓(-3.730)
→
FY 2021.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2020/08/07 決10.800
-
1.345
-
1.315
-
-
0.900
-
235.270
-
25.000
-
2020/11/13 決10.800
→
1.345
→
1.315
→
-
0.900
→
235.270
→
25.000
→
2021/02/12 決10.800
→
1.345
→
1.315
→
-
0.900
→
235.270
→
25.000
→
2021/05/14 実10.526
↓(-0.274)
1.399
↑(+0.054)
1.411
↑(+0.096)
1.401
-
0.960
↑(+0.060)
251.170
↑(+15.900)
25.000
→
Delta from Initial Guidance↓(-0.274)
↑(+0.054)
↑(+0.096)
-
↑(+0.060)
↑(+15.900)
→
"""

# --- 日本電子材料業績予想修正履歴データ ---
FORECAST_TEXT_6855 = """
FY 2026.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2025/05/14 決25.500
-
3.750
-
3.650
-
-
2.500
-
197.920
-
50.000
-
2025/08/07 決25.500
→
3.750
→
3.650
→
-
2.500
→
197.920
→
50.000
→
FY 2025.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2024/05/14 決21.000
-
2.400
-
2.200
-
-
1.600
-
126.750
-
40.000
-
2024/09/25 修20.600
↓(-0.400)
3.600
↑(+1.200)
3.400
↑(+1.200)
-
2.400
↑(+0.800)
190.020
↑(+63.270)
55.000
↑(+15.000)
2024/11/08 決20.600
→
3.600
→
3.400
→
-
2.400
→
190.020
→
55.000
→
2025/02/07 決20.600
→
3.600
→
3.400
→
-
2.400
→
190.020
→
55.000
→
2025/05/14 実23.829
↑(+3.229)
4.585
↑(+0.985)
4.640
↑(+1.240)
4.627
-
3.454
↑(+1.054)
273.530
↑(+83.510)
70.000
↑(+15.000)
Delta from Initial Guidance↑(+2.829)
↑(+2.185)
↑(+2.440)
-
↑(+1.854)
↑(+146.780)
↑(+30.000)
FY 2024.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2023/05/15 決17.000
-
1.900
-
1.900
-
-
1.400
-
111.080
-
40.000
-
2023/08/08 決17.000
→
1.900
→
1.900
→
-
1.400
→
111.080
→
40.000
→
2023/09/26 修16.100
↓(-0.900)
0.300
↓(-1.600)
0.500
↓(-1.400)
-
0.390
↓(-1.010)
30.900
↓(-80.180)
-
2023/11/09 決16.100
→
0.300
→
0.500
→
-
0.390
→
30.900
→
40.000
-
2024/02/08 決16.100
→
0.300
→
0.500
→
-
0.390
→
30.900
→
40.000
→
2024/05/14 実17.461
↑(+1.361)
0.870
↑(+0.570)
1.007
↑(+0.507)
1.007
-
0.622
↑(+0.232)
49.320
↑(+18.420)
40.000
→
Delta from Initial Guidance↑(+0.461)
↓(-1.030)
↓(-0.893)
-
↓(-0.778)
↓(-61.760)
→
FY 2023.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2022/05/12 決24.000
-
3.600
-
3.600
-
-
2.600
-
212.750
-
40.000
-
2022/08/05 決24.000
→
3.600
→
3.600
→
-
2.600
→
212.750
→
40.000
→
2022/09/22 修21.400
↓(-2.600)
2.900
↓(-0.700)
3.100
↓(-0.500)
-
2.100
↓(-0.500)
166.540
↓(-46.210)
-
2022/11/09 決21.400
→
2.900
→
3.100
→
-
2.100
→
166.540
→
40.000
-
2023/02/08 決21.400
→
2.900
→
3.100
→
-
2.100
→
166.540
→
40.000
→
2023/05/15 実20.781
↓(-0.619)
3.205
↑(+0.305)
3.338
↑(+0.238)
3.465
-
2.612
↑(+0.512)
207.250
↑(+40.710)
40.000
→
Delta from Initial Guidance↓(-3.219)
↓(-0.395)
↓(-0.262)
-
↑(+0.012)
↓(-5.500)
→
FY 2022.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2021/05/12 決20.000
-
2.800
-
2.700
-
-
2.300
-
191.110
-
20.000
-
2021/08/06 決20.000
→
2.800
→
2.700
→
-
2.300
→
191.110
→
20.000
→
2021/11/09 決21.126
↑(+1.126)
4.211
↑(+1.411)
4.244
↑(+1.544)
-
3.045
↑(+0.745)
253.530
↑(+62.420)
40.000
↑(+20.000)
2022/02/08 決21.126
→
4.211
→
4.244
→
-
3.045
→
251.650
↓(-1.880)
40.000
→
2022/05/12 実23.599
↑(+2.473)
4.953
↑(+0.742)
5.092
↑(+0.848)
5.092
-
3.802
↑(+0.757)
311.170
↑(+59.520)
40.000
→
Delta from Initial Guidance↑(+3.599)
↑(+2.153)
↑(+2.392)
-
↑(+1.502)
↑(+120.060)
↑(+20.000)
"""

# --- JFEシステムズ業績予想修正履歴データ ---
FORECAST_TEXT_4832 = """
FY 2026.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2025/04/25 決58.620
-
6.300
-
6.400
-
-
4.260
-
135.630
-
68.000
-
2025/07/29 決58.620
→
6.300
→
6.400
→
-
4.260
→
135.630
→
68.000
→
FY 2025.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2024/04/25 決62.130
-
6.640
-
6.700
-
-
4.550
-
289.720
-
102.000
-
2024/07/26 決62.130
→
6.640
→
6.700
→
-
4.550
→
289.720
→
102.000
→
2024/10/29 決62.130
→
6.640
→
6.700
→
-
4.550
→
289.720
→
102.000
→
2025/01/28 決64.000
↑(+1.870)
7.340
↑(+0.700)
7.400
↑(+0.700)
-
5.140
↑(+0.590)
327.290
↑(+37.570)
115.000
↑(+13.000)
2025/04/25 実58.235
↓(-5.765)
6.575
↓(-0.765)
6.808
↓(-0.592)
7.667
-
5.442
↑(+0.302)
173.270
↓(-154.020)
122.000
↑(+7.000)
Delta from Initial Guidance↓(-3.895)
↓(-0.065)
↑(+0.108)
-
↑(+0.892)
↓(-116.450)
↑(+20.000)
FY 2024.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2023/04/27 決57.000
-
6.050
-
6.100
-
-
4.150
-
264.250
-
92.000
-
2023/07/26 決57.000
→
6.050
→
6.100
→
-
4.150
→
264.250
→
102.000
↑(+10.000)
2023/10/26 決61.300
↑(+4.300)
6.955
↑(+0.905)
7.000
↑(+0.900)
-
4.730
↑(+0.580)
301.180
↑(+36.930)
118.000
↑(+16.000)
2024/01/26 決61.300
→
6.955
→
7.000
→
-
4.730
→
301.180
→
118.000
→
2024/04/25 実56.696
↓(-4.604)
6.529
↓(-0.426)
6.749
↓(-0.251)
7.452
-
4.969
↑(+0.239)
158.180
↓(-143.000)
121.000
↑(+3.000)
Delta from Initial Guidance↓(-0.304)
↑(+0.479)
↑(+0.649)
-
↑(+0.819)
↓(-106.070)
↑(+29.000)
FY 2023.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2022/04/26 決54.000
-
5.670
-
5.700
-
-
3.740
-
238.140
-
85.000
-
2022/07/26 決54.000
→
5.670
→
5.700
→
-
3.740
→
238.140
→
85.000
→
2022/10/26 決55.000
↑(+1.000)
5.670
→
5.700
→
-
3.740
→
238.140
→
85.000
→
2023/01/26 決55.000
→
6.070
↑(+0.400)
6.100
↑(+0.400)
-
4.100
↑(+0.360)
261.060
↑(+22.920)
90.000
↑(+5.000)
2023/04/27 実51.617
↓(-3.383)
5.424
↓(-0.646)
5.612
↓(-0.488)
6.282
-
4.323
↑(+0.223)
275.290
↑(+14.230)
97.000
↑(+7.000)
Delta from Initial Guidance↓(-2.383)
↓(-0.246)
↓(-0.088)
-
↑(+0.583)
↑(+37.150)
↑(+12.000)
FY 2022.03売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2021/04/26 決48.000
-
4.760
-
4.800
-
-
3.100
-
197.390
-
60.000
-
2021/07/27 決48.000
→
4.760
→
4.800
→
-
3.100
→
197.390
→
60.000
→
2021/10/27 決51.000
↑(+3.000)
5.270
↑(+0.510)
5.300
↑(+0.500)
-
3.500
↑(+0.400)
222.860
↑(+25.470)
75.000
↑(+15.000)
2022/01/26 決51.000
→
5.470
↑(+0.200)
5.500
↑(+0.200)
-
3.640
↑(+0.140)
231.770
↑(+8.910)
75.000
→
2022/04/26 実46.357
↓(-4.643)
4.983
↓(-0.487)
5.111
↓(-0.389)
5.644
-
3.724
↑(+0.084)
237.120
↑(+5.350)
75.000
→
Delta from Initial Guidance↓(-1.643)
↑(+0.223)
↑(+0.311)
-
↑(+0.624)
↑(+39.730)
↑(+15.000)
"""

# --- テー・オー・ダブリュー業績予想修正履歴データ ---
FORECAST_TEXT_4767 = """
-売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2019/12/13 修-
-
-
-
-
-
31.500
-
FY 2026.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2025/08/07 決18.800
-
2.208
-
2.250
-
-
1.500
-
36.590
-
18.300
-
FY 2025.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2024/08/08 決18.000
-
2.120
-
2.150
-
-
1.428
-
35.170
-
15.000
-
2024/11/14 決18.000
→
2.120
→
2.150
→
-
1.428
→
35.170
→
15.000
→
2025/02/13 決18.000
→
2.120
→
2.150
→
-
1.428
→
35.170
→
15.000
→
2025/05/15 決18.000
→
2.120
→
2.150
→
-
1.428
→
35.170
→
15.000
→
2025/08/07 実17.783
↓(-0.217)
2.153
↑(+0.033)
2.194
↑(+0.044)
1.611
-
1.132
↓(-0.296)
27.720
↓(-7.450)
15.000
→
Delta from Initial Guidance↓(-0.217)
↑(+0.033)
↑(+0.044)
-
↓(-0.296)
↓(-7.450)
→
FY 2024.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2023/08/09 決14.000
-
1.370
-
1.400
-
-
0.915
-
22.740
-
14.000
-
2024/02/08 修16.000
↑(+2.000)
1.748
↑(+0.378)
1.777
↑(+0.377)
-
1.172
↑(+0.257)
28.950
↑(+6.210)
-
2024/02/08 決16.000
→
1.748
→
1.777
→
-
1.172
→
28.950
→
14.000
-
2024/05/15 決16.000
→
1.748
→
1.777
→
-
1.172
→
28.950
→
14.000
→
2024/06/14 修17.300
↑(+1.300)
1.920
↑(+0.172)
1.950
↑(+0.173)
-
1.267
↑(+0.095)
31.300
↑(+2.350)
-
2024/08/08 実17.504
↑(+0.204)
2.007
↑(+0.087)
2.058
↑(+0.108)
2.055
-
1.406
↑(+0.139)
34.710
↑(+3.410)
14.000
-
Delta from Initial Guidance↑(+3.504)
↑(+0.637)
↑(+0.658)
-
↑(+0.491)
↑(+11.970)
→
FY 2023.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2022/08/09 決11.700
-
0.992
-
1.015
-
-
0.174
-
3.855
-
14.400
-
2022/11/14 決11.700
→
0.992
→
1.015
→
-
0.174
→
3.855
→
14.400
→
2023/02/08 修12.000
↑(+0.300)
1.076
↑(+0.084)
1.100
↑(+0.085)
-
0.289
↑(+0.115)
7.010
↑(+3.155)
-
2023/02/08 決12.000
→
1.076
→
1.100
→
-
0.289
→
7.010
→
14.400
-
2023/05/15 決12.000
→
1.076
→
1.100
→
-
0.289
→
7.010
→
14.400
→
2023/08/09 実11.774
↓(-0.226)
1.151
↑(+0.075)
1.179
↑(+0.079)
0.554
-
0.356
↑(+0.067)
8.610
↑(+1.600)
14.400
→
Delta from Initial Guidance↑(+0.074)
↑(+0.159)
↑(+0.164)
-
↑(+0.182)
↑(+4.755)
→
FY 2022.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2021/08/10 決12.339
-
0.967
-
1.000
-
-
0.622
-
13.830
-
14.000
-
2021/11/12 決12.339
→
0.967
→
1.000
→
-
0.622
→
13.830
→
14.000
→
2022/02/08 決12.339
→
0.967
→
1.000
→
-
0.622
→
13.830
→
14.000
→
2022/05/13 決12.339
→
0.967
→
1.000
→
-
0.622
→
13.830
→
14.000
→
2022/06/15 修11.051
↓(-1.288)
0.801
↓(-0.166)
0.841
↓(-0.159)
-
0.543
↓(-0.079)
12.020
↓(-1.810)
-
2022/08/09 実11.134
↑(+0.083)
0.884
↑(+0.083)
0.924
↑(+0.083)
0.927
-
0.598
↑(+0.055)
13.220
↑(+1.200)
14.000
-
Delta from Initial Guidance↓(-1.205)
↓(-0.083)
↓(-0.076)
-
↓(-0.024)
↓(-0.610)
→
FY 2021.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2021/02/08 修11.644
-
0.224
-
0.262
-
-
0.158
-
3.530
-
12.900
-
2021/02/08 決11.644
→
0.224
→
0.262
→
-
0.158
→
3.530
→
12.900
→
2021/05/14 修11.726
↑(+0.082)
0.384
↑(+0.160)
0.426
↑(+0.164)
-
0.269
↑(+0.111)
5.990
↑(+2.460)
-
2021/05/14 決11.726
→
0.384
→
0.426
→
-
0.269
→
5.990
→
12.900
-
2021/06/24 修12.069
↑(+0.343)
0.558
↑(+0.174)
0.600
↑(+0.174)
-
0.387
↑(+0.118)
8.630
↑(+2.640)
-
2021/08/10 実12.209
↑(+0.140)
0.656
↑(+0.098)
0.699
↑(+0.099)
0.711
-
0.456
↑(+0.069)
10.140
↑(+1.510)
12.900
-
Delta from Initial Guidance↑(+0.565)
↑(+0.432)
↑(+0.437)
-
↑(+0.298)
↑(+6.610)
→
FY 2020.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2019/08/08 決16.829
-
2.040
-
2.040
-
-
1.352
-
60.200
-
30.000
-
2019/11/08 決16.829
→
2.040
→
2.040
→
-
1.352
→
60.200
→
30.000
→
2019/12/13 修17.424
↑(+0.595)
2.102
↑(+0.062)
2.115
↑(+0.075)
-
1.407
↑(+0.055)
62.620
↑(+2.420)
-
2020/02/06 決17.424
→
2.102
→
2.115
→
-
1.407
→
62.620
→
31.500
-
2020/05/15 決17.424
→
2.102
→
2.115
→
-
1.407
→
31.310
↓(-31.310)
24.000
↓(-7.500)
2020/06/15 修19.360
↑(+1.936)
2.212
↑(+0.110)
2.226
↑(+0.111)
-
1.486
↑(+0.079)
33.070
↑(+1.760)
-
2020/08/06 実19.326
↓(-0.034)
2.317
↑(+0.105)
2.333
↑(+0.107)
2.339
-
1.585
↑(+0.099)
35.260
↑(+2.190)
25.000
-
Delta from Initial Guidance↑(+2.497)
↑(+0.277)
↑(+0.293)
-
↑(+0.233)
↓(-24.940)
↓(-5.000)
FY 2019.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2018/08/08 決15.436
-
1.700
-
1.714
-
-
1.129
-
50.280
-
26.000
-
2018/11/09 決15.436
→
1.700
→
1.714
→
-
1.129
→
50.280
→
26.000
→
2019/02/07 決15.436
→
1.700
→
1.714
→
-
1.129
→
50.280
→
26.000
→
2019/05/10 修-
-
-
-
-
-
28.000
↑(+2.000)
2019/05/10 決15.436
-
1.700
-
1.714
-
-
1.129
-
50.280
-
28.000
→
2019/06/14 修16.068
↑(+0.632)
1.939
↑(+0.239)
1.958
↑(+0.244)
-
1.296
↑(+0.167)
57.700
↑(+7.420)
-
2019/08/08 実16.279
↑(+0.211)
1.996
↑(+0.057)
2.017
↑(+0.059)
2.014
-
1.345
↑(+0.049)
29.940
↓(-27.760)
29.000
-
Delta from Initial Guidance↑(+0.843)
↑(+0.296)
↑(+0.303)
-
↑(+0.216)
↓(-20.340)
↑(+3.000)
FY 2018.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2017/08/08 決16.673
-
1.851
-
1.851
-
-
1.175
-
52.300
-
-
2017/11/14 決16.673
→
1.851
→
1.851
→
-
1.175
→
52.300
→
27.000
-
2018/02/08 決16.673
→
1.851
→
1.851
→
-
1.175
→
52.300
→
27.000
-
2018/05/10 決16.673
→
1.851
→
1.851
→
-
1.175
→
52.300
→
27.000
-
2018/08/08 実16.689
↑(+0.016)
1.826
↓(-0.025)
1.873
↑(+0.022)
1.874
-
1.208
↑(+0.033)
53.750
↑(+1.450)
27.000
-
Delta from Initial Guidance↑(+0.016)
↓(-0.025)
↑(+0.022)
-
↑(+0.033)
↑(+1.450)
-
FY 2017.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2016/08/08 決16.032
-
1.793
-
1.792
-
-
1.185
-
52.920
-
-
2016/11/10 決16.032
→
1.793
→
1.792
→
-
1.185
→
52.920
→
-
2017/02/09 決16.032
→
1.793
→
1.792
→
-
1.185
→
52.820
↓(-0.100)
-
2017/05/10 決16.032
→
1.793
→
1.792
→
-
1.185
→
52.820
→
-
2017/08/08 実16.251
↑(+0.219)
1.812
↑(+0.019)
1.823
↑(+0.031)
1.820
-
1.207
↑(+0.022)
53.740
↑(+0.920)
26.000
-
Delta from Initial Guidance↑(+0.219)
↑(+0.019)
↑(+0.031)
-
↑(+0.022)
↑(+0.820)
-
FY 2016.06売上 Δ営利 Δ経利 Δ税前利 Δ純利 Δ一株益 Δ一株配 Δ2016/05/10 決15.119
-
1.579
-
1.583
-
-
1.012
-
45.200
-
-
2016/08/08 実15.230
↑(+0.111)
1.678
↑(+0.099)
1.682
↑(+0.099)
-
1.083
↑(+0.071)
48.350
↑(+3.150)
-
Delta from Initial Guidance↑(+0.111)
↑(+0.099)
↑(+0.099)
-
↑(+0.071)
↑(+3.150)
-
"""

def calculate_rsi(df, window=14):
    """RSIを計算"""
    delta = df['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss.replace(0, np.nan)
    df['RSI'] = 100 - (100 / (1 + rs))
    return df

def create_candlestick_chart(df, ticker_symbol, company_name):
    """ローソク足チャートを作成"""
    fig = go.Figure()
    
    try:
        if not df.empty and all(col in df.columns for col in ['Open', 'High', 'Low', 'Close']):
            fig.add_trace(go.Candlestick(
                x=df.index, 
                open=df['Open'], 
                high=df['High'], 
                low=df['Low'], 
                close=df['Close'], 
                name='ローソク足',
                increasing_line_color='red',
                decreasing_line_color='blue'
            ))
        else:
            fig.add_trace(go.Scatter(
                x=df.index, 
                y=df['Close'], 
                mode='lines', 
                name='終値', 
                line=dict(color='black', width=2)
            ))
    except Exception as e:
        fig.add_trace(go.Scatter(
            x=df.index, 
            y=df['Close'], 
            mode='lines', 
            name='終値', 
            line=dict(color='black', width=2)
        ))
    
    # 移動平均線を追加
    if 'MA20' in df.columns:
        fig.add_trace(go.Scatter(
            x=df.index, 
            y=df['MA20'], 
            mode='lines', 
            name='MA20',
            line=dict(color='orange', width=1)
        ))
    
    if 'MA50' in df.columns:
        fig.add_trace(go.Scatter(
            x=df.index, 
            y=df['MA50'], 
            mode='lines', 
            name='MA50',
            line=dict(color='purple', width=1)
        ))
    
    fig.update_layout(
        title=f'{company_name} ({ticker_symbol}) ローソク足チャート',
        yaxis_title='価格 (¥)',
        xaxis_title='日付'
    )
    
    return fig

def create_rsi_chart(df, ticker_symbol):
    """RSIチャートを作成"""
    fig = go.Figure()
    
    if 'RSI' in df.columns:
        fig.add_trace(go.Scatter(
            x=df.index, 
            y=df['RSI'], 
            mode='lines', 
            name='RSI',
            line=dict(color='blue', width=2)
        ))
        
        # RSIの水平線を追加
        fig.add_hline(y=70, line_dash="dash", line_color="red", annotation_text="売られすぎ")
        fig.add_hline(y=30, line_dash="dash", line_color="green", annotation_text="買われすぎ")
    
    fig.update_layout(
        title=f'{ticker_symbol} RSI (14日間)', 
        yaxis_title='RSI', 
        yaxis=dict(range=[0, 100])
    )
    
    return fig

def get_japanese_company_name(ticker, ticker_info):
    """日本語企業名を取得する関数"""
    if ticker in JAPANESE_COMPANY_NAMES:
        return JAPANESE_COMPANY_NAMES[ticker]
    else:
        return ticker_info.get('longName', ticker)

def analyze_price_movement_factors(stock_data, fundamental_data, ticker):
    """株価変動の要因を分析する関数"""
    analysis_results = []
    
    if stock_data.empty:
        return analysis_results
    
    # 株価データの基本統計
    stock_data = stock_data.copy()
    stock_data['Returns'] = stock_data['Close'].pct_change()
    stock_data['MA20'] = stock_data['Close'].rolling(window=20).mean()
    stock_data['MA50'] = stock_data['Close'].rolling(window=50).mean()
    
    # 大きな価格変動を特定（5%以上の変動）
    significant_moves = stock_data[abs(stock_data['Returns']) > 0.05].copy()
    
    if not significant_moves.empty:
        # 最近の大きな変動を分析
        recent_moves = significant_moves.tail(10)
        
        for date, row in recent_moves.iterrows():
            move_type = "上昇" if row['Returns'].item() > 0 else "下落"
            move_pct = row['Returns'].item() * 100
            
            # テクニカル要因の分析
            technical_factors = []
            
            # 移動平均線との関係
            if row['Close'].item() > row['MA20'].item() and row['Close'].item() > row['MA50'].item():
                technical_factors.append("移動平均線上抜け")
            elif row['Close'].item() < row['MA20'].item() and row['Close'].item() < row['MA50'].item():
                technical_factors.append("移動平均線下抜け")
            
            # 出来高の分析
            avg_volume = stock_data['Volume'].rolling(window=20).mean().loc[date]
            if row['Volume'].item() > avg_volume.item() * 1.5:
                technical_factors.append("高出来高")
            elif row['Volume'].item() < avg_volume.item() * 0.5:
                technical_factors.append("低出来高")
            
            # ファンダメンタル要因の分析（可能な場合）
            fundamental_factors = []
            if fundamental_data is not None and not fundamental_data.empty:
                # 業績発表時期の特定（四半期末付近）
                month = date.month
                if month in [3, 6, 9, 12]:
                    fundamental_factors.append("決算発表時期")
                
                # 売上・利益の成長率分析
                if '売上高' in fundamental_data.columns:
                    latest_revenue = fundamental_data['売上高'].iloc[-1]
                    prev_revenue = fundamental_data['売上高'].iloc[-2] if len(fundamental_data) > 1 else latest_revenue
                    revenue_growth = ((latest_revenue - prev_revenue) / prev_revenue) * 100 if prev_revenue > 0 else 0
                    
                    if revenue_growth > 10:
                        fundamental_factors.append("売上高大幅成長")
                    elif revenue_growth < -10:
                        fundamental_factors.append("売上高大幅減少")
            
            # 銘柄別の特徴的な要因
            sector_factors = get_sector_specific_factors(ticker, date, move_type)
            
            analysis_results.append({
                'Date': date.strftime('%Y-%m-%d'),
                'Move_Type': move_type,
                'Move_Percent': f"{move_pct:+.1f}%",
                'Technical_Factors': technical_factors,
                'Fundamental_Factors': fundamental_factors,
                'Sector_Factors': sector_factors,
                'Price': row['Close'].item(),
                'Volume': row['Volume'].item()
            })
    
    return analysis_results

def get_sector_specific_factors(ticker, date, move_type):
    """銘柄別の業界特有の要因を分析"""
    factors = []
    
    # 各銘柄の業界特性に基づく要因分析
    if ticker == '6357.T':  # 三精テクノロジーズ
        factors.append("製造業：設備投資動向・材料価格変動")
        if move_type == "上昇":
            factors.append("自動化需要増加・製造業景気回復")
        else:
            factors.append("設備投資抑制・製造業景気悪化")
    
    elif ticker == '4816.T':  # 東映アニメーション
        factors.append("エンタメ業界：コンテンツ人気・配信動向")
        if move_type == "上昇":
            factors.append("ヒット作品・海外展開成功")
        else:
            factors.append("コンテンツ不振・競合激化")
    
    elif ticker == '2991.T':  # ランドネット
        factors.append("不動産業界：金利動向・不動産市況")
        if move_type == "上昇":
            factors.append("不動産価格上昇・取引活発化")
        else:
            factors.append("金利上昇・不動産市況悪化")
    
    elif ticker == '7564.T':  # ワークマン
        factors.append("小売業界：消費者動向・季節要因")
        if move_type == "上昇":
            factors.append("アウトドア需要増・新商品好調")
        else:
            factors.append("消費低迷・競合激化")
    
    elif ticker == '7711.T':  # 助川電気工業
        factors.append("電気機器業界：設備投資・技術革新")
        if move_type == "上昇":
            factors.append("電力インフラ投資・技術革新")
        else:
            factors.append("設備投資抑制・競合激化")
    
    elif ticker == '6405.T':  # 鈴茂器工
        factors.append("食品機械業界：外食産業動向")
        if move_type == "上昇":
            factors.append("外食産業回復・自動化需要")
        else:
            factors.append("外食産業低迷・設備投資抑制")
    
    elif ticker == '2428.T':  # ウェルネット
        factors.append("決済サービス業界：デジタル化・規制動向")
        if move_type == "上昇":
            factors.append("キャッシュレス普及・新サービス")
        else:
            factors.append("競合激化・規制強化")
    
    elif ticker == '6231.T':  # 木村工機
        factors.append("産業機械業界：製造業設備投資")
        if move_type == "上昇":
            factors.append("製造業設備投資増・自動化需要")
        else:
            factors.append("設備投資抑制・製造業低迷")
    
    elif ticker == '6855.T':  # 日本電子材料
        factors.append("半導体材料業界：半導体サイクル")
        if move_type == "上昇":
            factors.append("半導体需要増・技術革新")
        else:
            factors.append("半導体サイクル悪化・需要減")
    
    elif ticker == '4832.T':  # JFEシステムズ
        factors.append("ITサービス業界：DX需要・プロジェクト動向")
        if move_type == "上昇":
            factors.append("DX案件増加・大型受注")
        else:
            factors.append("プロジェクト遅延・IT投資抑制")
    
    elif ticker == '4767.T':  # テー・オー・ダブリュー
        factors.append("広告業界：景気動向・企業広告費")
        if move_type == "上昇":
            factors.append("景気回復・広告費増加")
        else:
            factors.append("景気悪化・広告費削減")
    
    return factors

def parse_forecast_history(forecast_text):
    """業績予想修正履歴データを解析してDataFrameに変換"""
    try:
        lines = forecast_text.strip().split('\n')
        data = []
        current_fy = None
        current_guidance = {}
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
                
            # 年度の検出
            if line.startswith('FY '):
                current_fy = line.split()[1]
                current_guidance = {}
                continue
                
            # データ行の処理
            if any(char in line for char in ['決', '実', '修']):
                parts = line.split()
                if len(parts) >= 2:
                    date_part = parts[0]
                    type_part = parts[1] if len(parts) > 1 else ''
                    
                    # 日付とタイプの抽出
                    if '/' in date_part:
                        date = date_part
                        guidance_type = type_part
                    else:
                        date = ''
                        guidance_type = date_part
                    
                    # 数値データの抽出（簡易版）
                    values = []
                    for i in range(2, len(parts)):
                        try:
                            val = float(parts[i].replace('↑', '').replace('↓', '').replace('→', '').replace('(', '').replace(')', '').replace('+', '').replace('-', ''))
                            values.append(val)
                        except:
                            values.append(None)
                    
                    if len(values) >= 6:  # 最低限必要なデータ
                        data.append({
                            'FY': current_fy,
                            'Date': date,
                            'Type': guidance_type,
                            'Revenue': values[0] if values[0] else None,
                            'Operating_Profit': values[1] if values[1] else None,
                            'Ordinary_Profit': values[2] if values[2] else None,
                            'Net_Profit': values[3] if values[3] else None,
                            'EPS': values[4] if values[4] else None,
                            'Dividend': values[5] if values[5] else None
                        })
        
        return pd.DataFrame(data)
    
    except Exception as e:
        # エラーが発生した場合は空のDataFrameを返す
        return pd.DataFrame()

def analyze_forecast_accuracy(df):
    """業績予想の精度を分析"""
    try:
        accuracy_data = []
        
        # データが空の場合は空のDataFrameを返す
        if df.empty:
            return pd.DataFrame()
        
        # 年度ごとに分析
        for fy in df['FY'].unique():
            fy_data = df[df['FY'] == fy].copy()
            
            # 初期予想と実績を取得
            initial = fy_data[fy_data['Type'] == '決'].iloc[0] if len(fy_data[fy_data['Type'] == '決']) > 0 else None
            actual = fy_data[fy_data['Type'] == '実'].iloc[0] if len(fy_data[fy_data['Type'] == '実']) > 0 else None
            
            if initial is not None and actual is not None:
                metrics = ['Revenue', 'Operating_Profit', 'Ordinary_Profit', 'Net_Profit']
                
                for metric in metrics:
                    if initial[metric] is not None and actual[metric] is not None and initial[metric] != 0:
                        forecast_value = initial[metric]
                        actual_value = actual[metric]
                        error_rate = ((actual_value - forecast_value) / forecast_value) * 100
                        
                        accuracy_data.append({
                            'FY': fy,
                            'Metric': metric,
                            'Forecast': forecast_value,
                            'Actual': actual_value,
                            'Error_Rate': error_rate,
                            'Abs_Error_Rate': abs(error_rate)
                        })
        
        return pd.DataFrame(accuracy_data)
    
    except Exception as e:
        # エラーが発生した場合は空のDataFrameを返す
        return pd.DataFrame()

def create_forecast_analysis_charts(forecast_df, accuracy_df):
    """業績予想分析チャートを作成"""
    charts = {}
    
    # 1. 売上・営業利益の推移チャート
    fig_trend = go.Figure()
    
    for metric in ['Revenue', 'Operating_Profit']:
        metric_name = '売上高' if metric == 'Revenue' else '営業利益'
        
        # 実績値のプロット
        actual_data = forecast_df[forecast_df['Type'] == '実']
        if not actual_data.empty:
            fig_trend.add_trace(go.Scatter(
                x=actual_data['FY'],
                y=actual_data[metric],
                mode='lines+markers',
                name=f'{metric_name}（実績）',
                line=dict(width=3),
                marker=dict(size=10)
            ))
        
        # 予想値のプロット
        forecast_data = forecast_df[forecast_df['Type'] == '決']
        if not forecast_data.empty:
            fig_trend.add_trace(go.Scatter(
                x=forecast_data['FY'],
                y=forecast_data[metric],
                mode='lines+markers',
                name=f'{metric_name}（予想）',
                line=dict(dash='dash', width=2),
                marker=dict(size=8)
            ))
    
    fig_trend.update_layout(
        title='売上高・営業利益の予想vs実績推移',
        yaxis_title='金額 (億円)',
        xaxis_title='年度',
        height=400
    )
    charts['trend'] = fig_trend
    
    # 2. 予想精度分析チャート
    if not accuracy_df.empty:
        fig_accuracy = go.Figure()
        
        for metric in accuracy_df['Metric'].unique():
            metric_data = accuracy_df[accuracy_df['Metric'] == metric]
            metric_name = {
                'Revenue': '売上高',
                'Operating_Profit': '営業利益',
                'Ordinary_Profit': '経常利益',
                'Net_Profit': '純利益'
            }.get(metric, metric)
            
            fig_accuracy.add_trace(go.Bar(
                x=metric_data['FY'],
                y=metric_data['Error_Rate'],
                name=metric_name,
                text=[f"{x:+.1f}%" for x in metric_data['Error_Rate']],
                textposition='auto'
            ))
        
        fig_accuracy.update_layout(
            title='業績予想の誤差率分析（実績 vs 初期予想）',
            yaxis_title='誤差率 (%)',
            xaxis_title='年度',
            height=400
        )
        fig_accuracy.add_hline(y=0, line_dash="dash", line_color="black")
        charts['accuracy'] = fig_accuracy
    
    return charts

def process_financial_csv(file_path_or_handle):
    """CSVを読み込み整形する関数"""
    try:
        if isinstance(file_path_or_handle, str):
            # ファイルパス
            df = pd.read_csv(file_path_or_handle, index_col=0, encoding='utf-8')
        else:
            # ファイルハンドル
            df = pd.read_csv(file_path_or_handle, index_col=0, encoding='utf-8')

        # インデックスが日付形式の場合の処理
        if df.index.dtype == 'object':
            try:
                df.index = pd.to_datetime(df.index)
                df.sort_index(inplace=True)
                
                # データを数値に変換
                for col in df.columns:
                    df[col] = pd.to_numeric(df[col], errors='coerce')
                
                # 全てがNaNの行を削除
                df.dropna(how='all', inplace=True)
                
                return df
            except (ValueError, TypeError):
                pass
        
        # 通期データ抽出方式
        annual_col_pattern = re.compile(r'^\d{4}/\d{1,2}$')
        annual_columns = [col for col in df.columns if annual_col_pattern.match(col)]
        
        if not annual_columns:
            for col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')
            df.dropna(how='all', inplace=True)
            return df
        
        df_annual = df[annual_columns].copy()
        df_annual = df_annual.replace({',': ''}, regex=True)
        for col in df_annual.columns:
            df_annual[col] = pd.to_numeric(df_annual[col], errors='coerce')

        df_annual.dropna(how='all', inplace=True)
        df_transposed = df_annual.T
        df_transposed.index = pd.to_datetime(df_transposed.index, format='%Y/%m')
        df_transposed.sort_index(inplace=True)
        
        return df_transposed
        
    except Exception as e:
        st.error(f"CSVファイルの処理中にエラーが発生しました: {e}")
        return None

def calculate_technicals(df):
    """テクニカル指標を計算"""
    df['MA5'] = df['Close'].rolling(window=5).mean()
    df['MA25'] = df['Close'].rolling(window=25).mean()
    df['MA75'] = df['Close'].rolling(window=75).mean()
    delta = df['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss.replace(0, np.nan)
    df['RSI'] = 100 - (100 / (1 + rs))
    return df

def create_candlestick_chart(df, ticker_symbol, company_name):
    """ローソク足チャートを作成"""
    fig = go.Figure()
    
    try:
        if not df.empty and all(col in df.columns for col in ['Open', 'High', 'Low', 'Close']):
            fig.add_trace(go.Candlestick(
                x=df.index, 
                open=df['Open'], 
                high=df['High'], 
                low=df['Low'], 
                close=df['Close'], 
                name='ローソク足',
                increasing_line_color='red',
                decreasing_line_color='blue'
            ))
        else:
            fig.add_trace(go.Scatter(
                x=df.index, 
                y=df['Close'], 
                mode='lines', 
                name='終値', 
                line=dict(color='black', width=2)
            ))
    except Exception as e:
        fig.add_trace(go.Scatter(
            x=df.index, 
            y=df['Close'], 
            mode='lines', 
            name='終値', 
            line=dict(color='black', width=2)
        ))
    
    # 移動平均線
    if 'MA25' in df.columns:
        fig.add_trace(go.Scatter(
            x=df.index, 
            y=df['MA25'], 
            mode='lines', 
            name='25日移動平均線', 
            line=dict(color='orange', width=1)
        ))
    
    if 'MA75' in df.columns:
        fig.add_trace(go.Scatter(
            x=df.index, 
            y=df['MA75'], 
            mode='lines', 
            name='75日移動平均線', 
            line=dict(color='skyblue', width=1)
        ))
    
    fig.update_layout(
        title=f'{company_name} ({ticker_symbol}) 株価チャート', 
        yaxis_title='株価 (JPY)', 
        xaxis_rangeslider_visible=False,
        xaxis_title='日付',
        showlegend=True
    )
    return fig

def create_rsi_chart(df, ticker_symbol):
    """RSIチャートを作成"""
    fig = go.Figure()
    fig.add_trace(go.Scatter(x=df.index, y=df['RSI'], mode='lines', name='RSI', line=dict(color='purple')))
    fig.add_hline(y=70, line_dash="dot", line_color="red", annotation_text="買われすぎ (70%)", annotation_position="bottom right")
    fig.add_hline(y=30, line_dash="dot", line_color="green", annotation_text="売られすぎ (30%)", annotation_position="bottom right")
    fig.update_layout(title=f'{ticker_symbol} RSI (14日間)', yaxis_title='RSI', yaxis=dict(range=[0, 100]))
    return fig

def create_rolling_volatility_chart(df, ticker_symbol, window=30):
    """ローリングボラティリティチャートを作成"""
    try:
        # 日次リターンの計算
        if isinstance(df.columns, pd.MultiIndex):
            close_prices = df.iloc[:, df.columns.get_level_values(0) == 'Close'].iloc[:, 0]
        else:
            close_prices = df['Close']
        
        daily_returns = close_prices.pct_change().dropna()
        
        # ローリングボラティリティ計算（年率換算）
        rolling_vol = daily_returns.rolling(window=window).std() * np.sqrt(252)
        
        fig = go.Figure()
        fig.add_trace(go.Scatter(
            x=rolling_vol.index, 
            y=rolling_vol * 100,  # パーセント表示
            mode='lines',
            name=f'{window}日ローリングボラティリティ',
            line=dict(color='orange', width=2)
        ))
        
        # 平均線を追加
        avg_vol = rolling_vol.mean() * 100
        fig.add_hline(
            y=avg_vol, 
            line_dash="dash", 
            line_color="gray", 
            annotation_text=f"平均: {avg_vol:.1f}%"
        )
        
        fig.update_layout(
            title=f'{ticker_symbol} ローリングボラティリティ ({window}日)',
            yaxis_title='年間ボラティリティ (%)',
            height=400
        )
        return fig
    except Exception as e:
        # エラー時は空のチャートを返す
        fig = go.Figure()
        fig.add_annotation(text=f"チャート作成エラー: {str(e)}", xref="paper", yref="paper", x=0.5, y=0.5)
        return fig

def create_returns_histogram(daily_returns, ticker_symbol):
    """日次リターンのヒストグラムを作成"""
    try:
        fig = go.Figure()
        
        # ヒストグラム
        fig.add_trace(go.Histogram(
            x=daily_returns * 100,  # パーセント表示
            nbinsx=50,
            name='日次リターン分布',
            marker_color='lightblue',
            opacity=0.7
        ))
        
        # 統計情報
        mean_return = daily_returns.mean() * 100
        std_return = daily_returns.std() * 100
        
        # 平均線
        fig.add_vline(
            x=mean_return, 
            line_dash="dash", 
            line_color="red", 
            annotation_text=f"平均: {mean_return:.2f}%"
        )
        
        # 標準偏差の範囲を表示
        fig.add_vline(
            x=mean_return + std_return, 
            line_dash="dot", 
            line_color="orange", 
            annotation_text=f"+1σ: {mean_return + std_return:.2f}%"
        )
        fig.add_vline(
            x=mean_return - std_return, 
            line_dash="dot", 
            line_color="orange", 
            annotation_text=f"-1σ: {mean_return - std_return:.2f}%"
        )
        
        fig.update_layout(
            title=f'{ticker_symbol} 日次リターン分布',
            xaxis_title='日次リターン (%)',
            yaxis_title='頻度',
            height=400,
            bargap=0.1
        )
        return fig
    except Exception as e:
        # エラー時は空のチャートを返す
        fig = go.Figure()
        fig.add_annotation(text=f"チャート作成エラー: {str(e)}", xref="paper", yref="paper", x=0.5, y=0.5)
        return fig

def find_financial_csv(ticker_code):
    """銘柄コードに対応するCSVファイルを自動検索"""
    clean_code = ticker_code.replace('.T', '')
    csv_filename = f"cleaned_financials_{clean_code}.csv"
    
    if os.path.exists(csv_filename):
        return csv_filename
    return None

def get_available_financial_tickers():
    """利用可能な財務データ銘柄を取得"""
    csv_files = [f for f in os.listdir('.') if f.startswith('cleaned_financials_') and f.endswith('.csv')]
    tickers = []
    for csv_file in csv_files:
        # ファイル名から銘柄コードを抽出
        code = csv_file.replace('cleaned_financials_', '').replace('.csv', '')
        ticker = f"{code}.T"
        tickers.append(ticker)
    return sorted(tickers)

def get_valuation_metrics(ticker_info, fundamental_data):
    """
    バリュエーション指標を取得・計算する関数
    
    Args:
        ticker_info (dict): yf.Ticker.info オブジェクト
        fundamental_data (pd.DataFrame): 財務CSVのDataFrame
    
    Returns:
        dict: バリュエーション指標の辞書
    """
    metrics = {}
    
    try:
        # PER (株価収益率)
        per = ticker_info.get('trailingPE')
        if per is None or per <= 0:
            per = ticker_info.get('forwardPE')
        metrics['PER'] = per if per and per > 0 else None
        
        # PBR (株価純資産倍率)
        pbr = ticker_info.get('priceToBook')
        metrics['PBR'] = pbr if pbr and pbr > 0 else None
        
        # ROE (自己資本利益率)
        roe = ticker_info.get('returnOnEquity')
        
        # ROEをパーセント表示に変換（yfinanceは小数で返すことが多い）
        if roe is not None and roe > 0:
            if roe < 1:  # 小数の場合はパーセントに変換
                roe = roe * 100
        
        # ROEが取得できない場合は財務データから計算
        if (roe is None or roe <= 0) and fundamental_data is not None and not fundamental_data.empty:
            try:
                # 実際のデータがある最新年度を取得（NaNでない行を探す）
                for i in range(len(fundamental_data) - 1, -1, -1):
                    latest_data = fundamental_data.iloc[i]
                    net_income = latest_data.get('当期利益')
                    equity = latest_data.get('自己資本')
                    
                    # NaNでない有効なデータが見つかった場合
                    if (net_income is not None and not pd.isna(net_income) and 
                        equity is not None and not pd.isna(equity) and equity > 0):
                        roe = (net_income / equity) * 100  # パーセント表示
                        break
            except (IndexError, KeyError, TypeError):
                pass
        
        metrics['ROE'] = roe if roe is not None and roe > 0 else None
        
        # 配当利回り
        dividend_yield = ticker_info.get('dividendYield')
        if dividend_yield is not None and dividend_yield > 0:
            # yfinanceの配当利回りは既にパーセント形式の場合が多いので、調整
            if dividend_yield > 1:  # 1より大きい場合は既にパーセント
                dividend_yield = dividend_yield
            else:  # 1以下の場合は小数なのでパーセントに変換
                dividend_yield = dividend_yield * 100
        metrics['配当利回り'] = dividend_yield if dividend_yield is not None and dividend_yield > 0 else None
        
    except Exception as e:
        print(f"バリュエーション指標の計算中にエラーが発生しました: {e}")
        # エラーが発生した場合はすべてNoneで初期化
        metrics = {
            'PER': None,
            'PBR': None,
            'ROE': None,
            '配当利回り': None
        }
    
    return metrics

def create_integrated_analysis(ticker, stock_data, ticker_info, fundamental_data=None):
    """統合分析ページ"""
    company_name = get_japanese_company_name(ticker, ticker_info)
    
    # 基本情報表示
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        latest_price = stock_data['Close'].iloc[-1].item()
        st.metric("💰 最新株価", f"¥{latest_price:,.2f}")
    
    with col2:
        prev_price = stock_data['Close'].iloc[-2].item()
        change = latest_price - prev_price
        change_pct = (change / prev_price) * 100
        st.metric("📈 前日比", f"{change_pct:.2f}%", f"¥{change:+.2f}")
    
    with col3:
        rsi_value = stock_data['RSI'].iloc[-1].item()
        rsi_signal = "🔥過熱" if rsi_value > 70 else "❄️売られすぎ" if rsi_value < 30 else "😐中立"
        st.metric("📊 RSI", f"{rsi_value:.1f}", rsi_signal)
    
    with col4:
        if fundamental_data is not None and '営業利益' in fundamental_data.columns:
            latest_profit = fundamental_data['営業利益'].iloc[-1] / 1e2
            # 営業利益が0または非常に小さい場合の処理
            if latest_profit <= 0.1:  # 0.1億円以下の場合
                st.metric("💼 営業利益", "予想値設定可能", help="実績値が小さいため予想値を設定できます")
            else:
                st.metric("💼 営業利益", f"{latest_profit:.1f}億円")
        else:
            market_cap = ticker_info.get('marketCap', 0) / 1e8 if ticker_info.get('marketCap') else 0
            st.metric("🏢 時価総額", f"{market_cap:,.0f}億円")
    
    # チャートエリア
    col_chart1, col_chart2 = st.columns(2)
    
    with col_chart1:
        st.write("**📈 株価チャート (直近6ヶ月)**")
        recent_data = stock_data.tail(120)  # 約6ヶ月
        fig_stock = create_candlestick_chart(recent_data, ticker, company_name)
        fig_stock.update_layout(height=400)
        st.plotly_chart(fig_stock, use_container_width=True)
    
    with col_chart2:
        if fundamental_data is not None and '営業利益' in fundamental_data.columns:
            st.write("**🏢 営業利益推移**")
            fig_profit = go.Figure()
            
            # 実績データ
            fig_profit.add_trace(go.Scatter(
                x=fundamental_data.index,
                y=fundamental_data['営業利益'] / 1e2,  # 億円
                mode='lines+markers',
                name='営業利益（実績）',
                line=dict(color='green', width=3),
                marker=dict(size=8)
            ))
            
            # 予想値がある場合は追加
            forecast_key_profit = f"forecast_profit_{ticker}"
            if forecast_key_profit in st.session_state and st.session_state[forecast_key_profit] > 0:
                forecast_profit = st.session_state[forecast_key_profit]
                
                # 予想値用の将来日付を作成（最新データの1年後）
                last_date = fundamental_data.index[-1]
                if hasattr(last_date, 'to_pydatetime'):
                    forecast_date = last_date.to_pydatetime().replace(year=last_date.year + 1)
                else:
                    forecast_date = pd.to_datetime(str(int(last_date.split('-')[0]) + 1) + '-03-01')
                
                # 予想値をプロット
                fig_profit.add_trace(go.Scatter(
                    x=[last_date, forecast_date],
                    y=[fundamental_data['営業利益'].iloc[-1] / 1e2, forecast_profit],
                    mode='lines+markers',
                    name='営業利益（予想）',
                    line=dict(color='orange', width=3, dash='dash'),
                    marker=dict(size=10, symbol='star')
                ))
            
            fig_profit.update_layout(
                title='営業利益推移（実績 + 予想）',
                yaxis_title='営業利益 (億円)',
                height=400
            )
            st.plotly_chart(fig_profit, use_container_width=True)
        else:
            st.write("**📊 RSI推移**")
            fig_rsi = create_rsi_chart(stock_data, ticker)
            fig_rsi.update_layout(height=400)
            st.plotly_chart(fig_rsi, use_container_width=True)
    
    # 株価変動要因分析
    st.subheader('🔍 株価変動要因分析')
    
    # 株価変動要因の分析を実行
    price_factors = analyze_price_movement_factors(stock_data, fundamental_data, ticker)
    
    if price_factors:
        st.write("**最近の主要な株価変動とその要因**")
        
        # 上昇と下落を分けて表示
        upward_moves = [move for move in price_factors if move['Move_Type'] == '上昇']
        downward_moves = [move for move in price_factors if move['Move_Type'] == '下落']
        
        col_up, col_down = st.columns(2)
        
        with col_up:
            st.write("**🟢 上昇要因分析**")
            if upward_moves:
                for i, move in enumerate(upward_moves[:3]):  # 最新3件
                    with st.expander(f"📈 {move['Date']} ({move['Move_Percent']})"):
                        st.write(f"**価格**: ¥{move['Price']:,.2f}")
                        st.write(f"**出来高**: {move['Volume']:,}")
                        
                        if move['Technical_Factors']:
                            st.write("**テクニカル要因**:")
                            for factor in move['Technical_Factors']:
                                st.write(f"• {factor}")
                        
                        if move['Fundamental_Factors']:
                            st.write("**ファンダメンタル要因**:")
                            for factor in move['Fundamental_Factors']:
                                st.write(f"• {factor}")
                        
                        if move['Sector_Factors']:
                            st.write("**業界特有要因**:")
                            for factor in move['Sector_Factors']:
                                st.write(f"• {factor}")
            else:
                st.info("大きな上昇は確認されていません")
        
        with col_down:
            st.write("**🔴 下落要因分析**")
            if downward_moves:
                for i, move in enumerate(downward_moves[:3]):  # 最新3件
                    with st.expander(f"📉 {move['Date']} ({move['Move_Percent']})"):
                        st.write(f"**価格**: ¥{move['Price']:,.2f}")
                        st.write(f"**出来高**: {move['Volume']:,}")
                        
                        if move['Technical_Factors']:
                            st.write("**テクニカル要因**:")
                            for factor in move['Technical_Factors']:
                                st.write(f"• {factor}")
                        
                        if move['Fundamental_Factors']:
                            st.write("**ファンダメンタル要因**:")
                            for factor in move['Fundamental_Factors']:
                                st.write(f"• {factor}")
                        
                        if move['Sector_Factors']:
                            st.write("**業界特有要因**:")
                            for factor in move['Sector_Factors']:
                                st.write(f"• {factor}")
            else:
                st.info("大きな下落は確認されていません")
        
        # 要因サマリー
        st.write("**📊 要因サマリー**")
        all_technical = []
        all_fundamental = []
        all_sector = []
        
        for move in price_factors:
            all_technical.extend(move['Technical_Factors'])
            all_fundamental.extend(move['Fundamental_Factors'])
            all_sector.extend(move['Sector_Factors'])
        
        col_summary1, col_summary2, col_summary3 = st.columns(3)
        
        with col_summary1:
            st.write("**主要テクニカル要因**")
            technical_counts = pd.Series(all_technical).value_counts()
            if not technical_counts.empty:
                for factor, count in technical_counts.head(3).items():
                    st.write(f"• {factor} ({count}回)")
            else:
                st.write("• 特徴的な要因なし")
        
        with col_summary2:
            st.write("**主要ファンダメンタル要因**")
            fundamental_counts = pd.Series(all_fundamental).value_counts()
            if not fundamental_counts.empty:
                for factor, count in fundamental_counts.head(3).items():
                    st.write(f"• {factor} ({count}回)")
            else:
                st.write("• 特徴的な要因なし")
        
        with col_summary3:
            st.write("**主要業界要因**")
            sector_counts = pd.Series(all_sector).value_counts()
            if not sector_counts.empty:
                for factor, count in sector_counts.head(3).items():
                    st.write(f"• {factor} ({count}回)")
            else:
                st.write("• 特徴的な要因なし")
    else:
        st.info("大きな株価変動は確認されていません（5%以上の変動を対象）")
    
    # 統合投資判断
    st.subheader('🎯 統合投資判断')
    
    col_tech, col_fund = st.columns(2)
    
    with col_tech:
        st.write("**📈 テクニカル分析シグナル**")
        
        # RSI判断
        rsi = stock_data['RSI'].iloc[-1].item()
        if rsi > 70:
            rsi_signal = "🔴 売りシグナル（過熱状態）"
            rsi_color = "error"
        elif rsi < 30:
            rsi_signal = "🟢 買いシグナル（売られすぎ）"
            rsi_color = "success"
        else:
            rsi_signal = "🟡 中立（様子見）"
            rsi_color = "warning"
        
        st.write(f"RSI ({rsi:.1f}): {rsi_signal}")
        
        # 移動平均判断
        ma25 = stock_data['MA25'].iloc[-1].item()
        ma75 = stock_data['MA75'].iloc[-1].item()
        current_price = stock_data['Close'].iloc[-1].item()
        
        if current_price > ma25 > ma75:
            ma_signal = "🟢 上昇トレンド継続"
            ma_color = "success"
        elif current_price < ma25 < ma75:
            ma_signal = "🔴 下降トレンド継続"
            ma_color = "error"
        else:
            ma_signal = "🟡 レンジ相場"
            ma_color = "warning"
        
        st.write(f"移動平均: {ma_signal}")
        
        # テクニカル総合判断
        tech_score = 0
        if rsi_color == "success":
            tech_score += 1
        elif rsi_color == "error":
            tech_score -= 1
        
        if ma_color == "success":
            tech_score += 1
        elif ma_color == "error":
            tech_score -= 1
        
        if tech_score >= 1:
            st.success("📈 テクニカル: 強気シグナル")
        elif tech_score <= -1:
            st.error("📉 テクニカル: 弱気シグナル")
        else:
            st.warning("😐 テクニカル: 中立")
    
    with col_fund:
        if fundamental_data is not None and len(fundamental_data) > 1:
            st.write("**🏢 ファンダメンタル分析シグナル**")
            
            # 予想値の取得
            forecast_key_revenue = f"forecast_revenue_{ticker}"
            forecast_key_profit = f"forecast_profit_{ticker}"
            use_forecast = (forecast_key_revenue in st.session_state and 
                          forecast_key_profit in st.session_state and 
                          st.session_state[forecast_key_profit] > 0)
            
            # 売上成長率判断（予想値も考慮）
            if '売上高' in fundamental_data.columns:
                if use_forecast:
                    # 予想値を使用
                    latest_revenue = st.session_state[forecast_key_revenue] * 1e8
                    prev_revenue = fundamental_data['売上高'].iloc[-1]
                    revenue_growth = ((latest_revenue - prev_revenue) / prev_revenue) * 100 if prev_revenue != 0 else 0
                    growth_type = "（予想）"
                else:
                    # 実績値を使用
                    latest_revenue = fundamental_data['売上高'].iloc[-1]
                    prev_revenue = fundamental_data['売上高'].iloc[-2]
                    revenue_growth = ((latest_revenue - prev_revenue) / prev_revenue) * 100 if prev_revenue != 0 else 0
                    growth_type = "（実績）"
                
                if revenue_growth > 10:
                    revenue_signal = "🟢 高成長"
                    revenue_color = "success"
                elif revenue_growth > 0:
                    revenue_signal = "🟡 成長"
                    revenue_color = "warning"
                else:
                    revenue_signal = "🔴 減収"
                    revenue_color = "error"
                
                st.write(f"売上成長率{growth_type} ({revenue_growth:.1f}%): {revenue_signal}")
            
            # 営業利益率判断（予想値も考慮）
            if '売上高' in fundamental_data.columns and '営業利益' in fundamental_data.columns:
                if use_forecast:
                    # 予想値を使用
                    latest_revenue = st.session_state[forecast_key_revenue] * 1e8
                    latest_profit = st.session_state[forecast_key_profit] * 1e8
                    margin_type = "（予想）"
                else:
                    # 実績値を使用
                    latest_revenue = fundamental_data['売上高'].iloc[-1]
                    latest_profit = fundamental_data['営業利益'].iloc[-1]
                    margin_type = "（実績）"
                
                operating_margin = (latest_profit / latest_revenue) * 100 if latest_revenue != 0 else 0
                
                if operating_margin > 15:
                    margin_signal = "🟢 高収益性"
                    margin_color = "success"
                elif operating_margin > 5:
                    margin_signal = "🟡 標準的"
                    margin_color = "warning"
                else:
                    margin_signal = "🔴 低収益性"
                    margin_color = "error"
                
                st.write(f"営業利益率{margin_type} ({operating_margin:.1f}%): {margin_signal}")
                
                # 予想値使用時の追加情報
                if use_forecast:
                    st.info("🔮 予想値を使用した分析結果です")
            
            # ファンダメンタル総合判断
            fund_score = 0
            if 'revenue_color' in locals() and revenue_color == "success":
                fund_score += 1
            elif 'revenue_color' in locals() and revenue_color == "error":
                fund_score -= 1
            
            if 'margin_color' in locals() and margin_color == "success":
                fund_score += 1
            elif 'margin_color' in locals() and margin_color == "error":
                fund_score -= 1
            
            if fund_score >= 1:
                st.success("🏢 ファンダメンタル: 良好")
            elif fund_score <= -1:
                st.error("🏢 ファンダメンタル: 懸念")
            else:
                st.warning("🏢 ファンダメンタル: 中立")
        else:
            st.info("ファンダメンタルデータが利用できません。\nテクニカル分析のみで判断してください。")
    
    # 投資判断ボタン
    st.write("---")
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button(f"🟢 {ticker} 買い推奨", key=f"summary_buy_{ticker}", use_container_width=True):
            st.success(f"{company_name} を買い推奨として記録")
    
    with col2:
        if st.button(f"🟡 {ticker} 様子見", key=f"summary_hold_{ticker}", use_container_width=True):
            st.warning(f"{company_name} を様子見として記録")
    
    with col3:
        if st.button(f"🔴 {ticker} 売り推奨", key=f"summary_sell_{ticker}", use_container_width=True):
            st.error(f"{company_name} を売り推奨として記録")
    
    # 財務指標予想値入力セクション
    st.subheader("🔮 財務指標予想値設定")
    
    # 業績予想履歴分析（対応銘柄のみ）
    forecast_data = None
    if ticker == '6357.T':
        forecast_data = FORECAST_TEXT_6357
        company_display = "三精テクノロジーズ"
    elif ticker == '4816.T':
        forecast_data = FORECAST_TEXT_4816
        company_display = "東映アニメーション"
    elif ticker == '2991.T':
        forecast_data = FORECAST_TEXT_2991
        company_display = "ランドネット"
    elif ticker == '7564.T':
        forecast_data = FORECAST_TEXT_7564
        company_display = "ワークマン"
    elif ticker == '7711.T':
        forecast_data = FORECAST_TEXT_7711
        company_display = "助川電気工業"
    elif ticker == '6405.T':
        forecast_data = FORECAST_TEXT_6405
        company_display = "鈴茂器工"
    elif ticker == '2428.T':
        forecast_data = FORECAST_TEXT_2428
        company_display = "ウェルネット"
    elif ticker == '6231.T':
        forecast_data = FORECAST_TEXT_6231
        company_display = "木村工機"
    elif ticker == '6855.T':
        forecast_data = FORECAST_TEXT_6855
        company_display = "日本電子材料"
    elif ticker == '4832.T':
        forecast_data = FORECAST_TEXT_4832
        company_display = "JFEシステムズ"
    elif ticker == '4767.T':
        forecast_data = FORECAST_TEXT_4767
        company_display = "テー・オー・ダブリュー"
    
    if forecast_data:
        st.subheader(f"📊 業績予想修正履歴分析（{company_display}）")
        
        # 業績予想履歴データの解析
        forecast_df = parse_forecast_history(forecast_data)
        
        if not forecast_df.empty:
            # タブで分析結果を表示
            tab1, tab2, tab3 = st.tabs(["📈 予想vs実績推移", "🎯 予想精度分析", "📋 詳細データ"])
            
            with tab1:
                st.write("**業績予想と実績の推移**")
                accuracy_df = analyze_forecast_accuracy(forecast_df)
                charts = create_forecast_analysis_charts(forecast_df, accuracy_df)
                
                if 'trend' in charts:
                    st.plotly_chart(charts['trend'], use_container_width=True)
                
                # 最新の予想精度サマリー
                if not accuracy_df.empty:
                    latest_fy = accuracy_df['FY'].max()
                    latest_accuracy = accuracy_df[accuracy_df['FY'] == latest_fy]
                    
                    st.write(f"**{latest_fy}年度の予想精度**")
                    col1, col2, col3, col4 = st.columns(4)
                    
                    metrics_display = {
                        'Revenue': ('売上高', col1),
                        'Operating_Profit': ('営業利益', col2),
                        'Ordinary_Profit': ('経常利益', col3),
                        'Net_Profit': ('純利益', col4)
                    }
                    
                    for metric, (name, col) in metrics_display.items():
                        metric_data = latest_accuracy[latest_accuracy['Metric'] == metric]
                        if not metric_data.empty:
                            error_rate = metric_data['Error_Rate'].iloc[0]
                            with col:
                                st.metric(
                                    name,
                                    f"{error_rate:+.1f}%",
                                    "上振れ" if error_rate > 0 else "下振れ" if error_rate < 0 else "一致"
                                )
            
            with tab2:
                st.write("**予想精度の分析**")
                if 'accuracy' in charts:
                    st.plotly_chart(charts['accuracy'], use_container_width=True)
                
                # 予想精度の統計
                if not accuracy_df.empty:
                    st.write("**予想精度統計**")
                    accuracy_stats = accuracy_df.groupby('Metric').agg({
                        'Abs_Error_Rate': ['mean', 'std', 'min', 'max'],
                        'Error_Rate': ['mean']
                    }).round(2)
                    
                    stats_display = pd.DataFrame({
                        '指標': ['売上高', '営業利益', '経常利益', '純利益'],
                        '平均誤差率(%)': [
                            accuracy_stats.loc['Revenue', ('Error_Rate', 'mean')] if 'Revenue' in accuracy_stats.index else 0,
                            accuracy_stats.loc['Operating_Profit', ('Error_Rate', 'mean')] if 'Operating_Profit' in accuracy_stats.index else 0,
                            accuracy_stats.loc['Ordinary_Profit', ('Error_Rate', 'mean')] if 'Ordinary_Profit' in accuracy_stats.index else 0,
                            accuracy_stats.loc['Net_Profit', ('Error_Rate', 'mean')] if 'Net_Profit' in accuracy_stats.index else 0
                        ],
                        '平均絶対誤差率(%)': [
                            accuracy_stats.loc['Revenue', ('Abs_Error_Rate', 'mean')] if 'Revenue' in accuracy_stats.index else 0,
                            accuracy_stats.loc['Operating_Profit', ('Abs_Error_Rate', 'mean')] if 'Operating_Profit' in accuracy_stats.index else 0,
                            accuracy_stats.loc['Ordinary_Profit', ('Abs_Error_Rate', 'mean')] if 'Ordinary_Profit' in accuracy_stats.index else 0,
                            accuracy_stats.loc['Net_Profit', ('Abs_Error_Rate', 'mean')] if 'Net_Profit' in accuracy_stats.index else 0
                        ]
                    })
                    
                    st.dataframe(stats_display, use_container_width=True)
                    
                    # 予想精度の傾向分析
                    st.write("**予想精度の傾向**")
                    
                    # 営業利益の予想精度に注目
                    op_accuracy = accuracy_df[accuracy_df['Metric'] == 'Operating_Profit']
                    if not op_accuracy.empty:
                        avg_error = op_accuracy['Error_Rate'].mean()
                        avg_abs_error = op_accuracy['Abs_Error_Rate'].mean()
                        
                        if avg_abs_error < 5:
                            precision_level = "🎯 高精度"
                            precision_color = "success"
                        elif avg_abs_error < 15:
                            precision_level = "👍 標準的"
                            precision_color = "warning"
                        else:
                            precision_level = "⚠️ 低精度"
                            precision_color = "error"
                        
                        if avg_error > 5:
                            bias_analysis = "📈 保守的予想（実績が上振れ傾向）"
                        elif avg_error < -5:
                            bias_analysis = "📉 楽観的予想（実績が下振れ傾向）"
                        else:
                            bias_analysis = "⚖️ バランス良い予想"
                        
                        if precision_color == "success":
                            st.success(f"**営業利益予想精度**: {precision_level} (平均絶対誤差: {avg_abs_error:.1f}%)")
                        elif precision_color == "warning":
                            st.warning(f"**営業利益予想精度**: {precision_level} (平均絶対誤差: {avg_abs_error:.1f}%)")
                        else:
                            st.error(f"**営業利益予想精度**: {precision_level} (平均絶対誤差: {avg_abs_error:.1f}%)")
                        
                        st.info(f"**予想傾向**: {bias_analysis}")
                        
                        # 企業別の特徴的な分析
                        if ticker == '4816.T':
                            # 東映アニメーションの特徴
                            revenue_accuracy = accuracy_df[accuracy_df['Metric'] == 'Revenue']
                            if not revenue_accuracy.empty:
                                revenue_avg_error = revenue_accuracy['Error_Rate'].mean()
                                if revenue_avg_error > 10:
                                    st.info("🎬 **東映アニメーションの特徴**: コンテンツビジネスの特性上、ヒット作品により売上が大幅に上振れする傾向があります。")
                        
                        elif ticker == '6357.T':
                            # 三精テクノロジーズの特徴
                            if avg_abs_error < 10:
                                st.info("⚙️ **三精テクノロジーズの特徴**: 製造業として比較的安定した業績予想精度を保っています。")
                        
                        elif ticker == '2991.T':
                            # ランドネットの特徴
                            revenue_accuracy = accuracy_df[accuracy_df['Metric'] == 'Revenue']
                            if not revenue_accuracy.empty:
                                revenue_avg_error = revenue_accuracy['Error_Rate'].mean()
                                if revenue_avg_error > 0:
                                    st.info("🏢 **ランドネットの特徴**: 不動産サービス業として、市場環境の変化により売上が上振れする傾向があります。")
                                    
                            # 配当修正の特徴
                            if len(forecast_df[forecast_df['Type'] == '修']) > 0:
                                st.warning("💰 **配当政策**: 期中に配当予想を修正するケースが見られ、業績連動型の配当政策を採用している可能性があります。")
                        
                        elif ticker == '7564.T':
                            # ワークマンの特徴
                            revenue_accuracy = accuracy_df[accuracy_df['Metric'] == 'Revenue']
                            if not revenue_accuracy.empty:
                                recent_performance = accuracy_df[accuracy_df['FY'].isin(['2024.03', '2025.03'])]
                                if not recent_performance.empty:
                                    recent_revenue_error = recent_performance[recent_performance['Metric'] == 'Revenue']['Error_Rate'].mean()
                                    if recent_revenue_error < 0:
                                        st.warning("👔 **ワークマンの特徴**: 近年、市場環境の変化により売上予想を下回る傾向が見られます。成長鈍化への対応が重要です。")
                                    else:
                                        st.info("👔 **ワークマンの特徴**: 作業服専門店として、労働市場の動向に敏感な業績変動を示します。")
                            
                            # 配当安定性
                            if avg_abs_error < 10:  # 比較的精度が高い場合
                                st.success("💰 **配当安定性**: 安定した配当政策を維持しており、株主還元に積極的です。")
                        
                        elif ticker == '7711.T':
                            # 助川電気工業の特徴
                            revenue_accuracy = accuracy_df[accuracy_df['Metric'] == 'Revenue']
                            if not revenue_accuracy.empty:
                                revenue_avg_error = revenue_accuracy['Error_Rate'].mean()
                                if revenue_avg_error > 0:
                                    st.info("⚡ **助川電気工業の特徴**: 電気機器製造業として、受注状況により業績が上振れする傾向があります。")
                            
                            # 小型株の成長性
                            op_accuracy = accuracy_df[accuracy_df['Metric'] == 'Operating_Profit']
                            if not op_accuracy.empty:
                                op_avg_error = op_accuracy['Error_Rate'].mean()
                                if op_avg_error > 15:  # 大幅な上振れ
                                    st.success("📈 **成長性**: 小型成長株として、営業利益が大幅に予想を上回る成長を実現しています。")
                                    
                            # 修正頻度の特徴
                            modification_count = len(forecast_df[forecast_df['Type'] == '修'])
                            total_guidance_count = len(forecast_df[forecast_df['Type'].isin(['決', '修'])])
                            if modification_count > 0 and total_guidance_count > 0:
                                modification_rate = (modification_count / total_guidance_count) * 100
                                if modification_rate > 20:
                                    st.warning("🔄 **予想修正頻度**: 期中での業績予想修正が比較的多く、事業環境の変化に敏感です。")
                        
                        elif ticker == '6405.T':
                            # 鈴茂器工の特徴
                            revenue_accuracy = accuracy_df[accuracy_df['Metric'] == 'Revenue']
                            if not revenue_accuracy.empty:
                                revenue_avg_error = revenue_accuracy['Error_Rate'].mean()
                                if revenue_avg_error < 0:
                                    st.info("🍙 **鈴茂器工の特徴**: 寿司ロボット製造業として、外食産業の動向に影響を受ける特性があります。")
                            
                            # 利益率改善の傾向
                            op_accuracy = accuracy_df[accuracy_df['Metric'] == 'Operating_Profit']
                            if not op_accuracy.empty:
                                op_avg_error = op_accuracy['Error_Rate'].mean()
                                if op_avg_error > 0:
                                    st.success("💼 **収益性**: 営業利益が予想を上回る傾向があり、効率的な事業運営を実現しています。")
                            
                            # 配当政策の特徴
                            dividend_data = forecast_df[forecast_df['Dividend'].notna() & (forecast_df['Dividend'] > 0)]
                            if not dividend_data.empty:
                                dividend_changes = dividend_data['Dividend'].diff().dropna()
                                if dividend_changes.sum() > 0:
                                    st.success("💰 **配当成長**: 継続的な増配傾向を示しており、株主還元に積極的です。")
                            
                            # 専門性の強み
                            if avg_abs_error < 15:  # 比較的精度が高い場合
                                st.info("🔧 **事業特性**: ニッチな市場でのシェアが高く、比較的安定した業績予想精度を保っています。")
                        
                        elif ticker == '2428.T':
                            # ウェルネットの特徴
                            revenue_accuracy = accuracy_df[accuracy_df['Metric'] == 'Revenue']
                            if not revenue_accuracy.empty:
                                revenue_avg_error = revenue_accuracy['Error_Rate'].mean()
                                if revenue_avg_error < 0:
                                    st.info("💳 **ウェルネットの特徴**: 決済サービス業として、キャッシュレス化の進展により市場環境に敏感です。")
                            
                            # 利益率改善の傾向
                            op_accuracy = accuracy_df[accuracy_df['Metric'] == 'Operating_Profit']
                            if not op_accuracy.empty:
                                op_avg_error = op_accuracy['Error_Rate'].mean()
                                if op_avg_error > 0:
                                    st.success("📈 **収益性向上**: 営業利益が予想を上回る傾向があり、事業効率化が進んでいます。")
                            
                            # 期中修正の特徴
                            recent_modifications = forecast_df[
                                (forecast_df['Type'] == '修') & 
                                (forecast_df['FY'].isin(['2025.06', '2024.06']))
                            ]
                            if not recent_modifications.empty:
                                st.warning("🔄 **期中修正傾向**: 事業環境の変化により期中での業績修正を実施する傾向があります。")
                            
                            # 配当成長の安定性
                            dividend_data = forecast_df[forecast_df['Dividend'].notna() & (forecast_df['Dividend'] > 0)]
                            if not dividend_data.empty:
                                dividend_trend = dividend_data['Dividend'].pct_change().dropna()
                                if dividend_trend.mean() > 0:
                                    st.success("💰 **配当成長**: 継続的な増配により株主還元を強化しています。")
                            
                            # デジタル決済市場の成長
                            if avg_abs_error < 20:  # 中程度の精度
                                st.info("💎 **市場ポジション**: デジタル決済市場の成長を取り込み、安定したビジネスモデルを構築しています。")
                        
                        elif ticker == '6231.T':
                            # 木村工機の特徴
                            revenue_accuracy = accuracy_df[accuracy_df['Metric'] == 'Revenue']
                            if not revenue_accuracy.empty:
                                revenue_avg_error = revenue_accuracy['Error_Rate'].mean()
                                if revenue_avg_error > 5:
                                    st.success("🏭 **木村工機の特徴**: 産業機械製造業として、設備投資需要の回復により業績が大幅に上振れしています。")
                            
                            # 高い利益率の実現
                            op_accuracy = accuracy_df[accuracy_df['Metric'] == 'Operating_Profit']
                            if not op_accuracy.empty:
                                op_avg_error = op_accuracy['Error_Rate'].mean()
                                if op_avg_error > 20:  # 大幅な上振れ
                                    st.success("💼 **収益性**: 営業利益が大幅に予想を上回り、高い収益性を実現しています。")
                            
                            # 期中上方修正の特徴
                            modification_data = forecast_df[forecast_df['Type'] == '修']
                            if not modification_data.empty:
                                upward_modifications = modification_data[
                                    (modification_data['Revenue'].notna()) & 
                                    (modification_data['Revenue'] > 0)
                                ]
                                if not upward_modifications.empty:
                                    st.info("📈 **上方修正傾向**: 期中での業績上方修正が多く、受注環境の改善を示しています。")
                            
                            # 配当政策の積極性
                            dividend_data = forecast_df[forecast_df['Dividend'].notna() & (forecast_df['Dividend'] > 0)]
                            if not dividend_data.empty:
                                recent_dividends = dividend_data.tail(3)['Dividend']
                                if recent_dividends.max() > recent_dividends.min() * 2:
                                    st.success("💰 **配当成長**: 大幅な増配により株主還元を強化しています。")
                            
                            # 産業機械業界の回復
                            if avg_abs_error > 15:  # 予想を大きく上回る傾向
                                st.info("🔧 **業界環境**: 産業機械需要の回復により、予想を大幅に上回る業績を実現しています。")
                        
                        elif ticker == '6855.T':
                            # 日本電子材料の特徴
                            revenue_accuracy = accuracy_df[accuracy_df['Metric'] == 'Revenue']
                            if not revenue_accuracy.empty:
                                revenue_avg_error = revenue_accuracy['Error_Rate'].mean()
                                if revenue_avg_error > 5:
                                    st.success("💎 **日本電子材料の特徴**: 半導体材料業界として、市場回復により業績が大幅に上振れしています。")
                            
                            # 利益変動の激しさ
                            op_accuracy = accuracy_df[accuracy_df['Metric'] == 'Operating_Profit']
                            if not op_accuracy.empty:
                                op_std = op_accuracy['Error_Rate'].std()
                                if op_std > 50:  # 大きな変動
                                    st.warning("📊 **業績変動**: 営業利益の変動が大きく、半導体サイクルの影響を強く受けています。")
                            
                            # 期中大幅修正の特徴
                            modification_data = forecast_df[forecast_df['Type'] == '修']
                            if not modification_data.empty:
                                large_modifications = modification_data[
                                    (modification_data['Operating_Profit'].notna()) & 
                                    (modification_data['Operating_Profit'].abs() > 1.0)
                                ]
                                if not large_modifications.empty:
                                    st.info("🔄 **大幅修正**: 期中での大幅な業績修正が多く、市場環境の変化に敏感です。")
                            
                            # 配当政策の特徴
                            dividend_data = forecast_df[forecast_df['Dividend'].notna() & (forecast_df['Dividend'] > 0)]
                            if not dividend_data.empty:
                                recent_dividends = dividend_data.tail(3)['Dividend']
                                if recent_dividends.max() > recent_dividends.min() * 1.5:
                                    st.success("💰 **配当変動**: 業績連動型の配当政策により、好調時には大幅な増配を実施しています。")
                            
                            # 半導体サイクル特性
                            if avg_abs_error > 20:  # 大きな予想誤差
                                st.info("🔬 **サイクル性**: 半導体材料業界の特性上、需給サイクルにより業績が大きく変動します。")
                        
                        elif ticker == '4832.T':
                            # JFEシステムズの特徴
                            revenue_accuracy = accuracy_df[accuracy_df['Metric'] == 'Revenue']
                            if not revenue_accuracy.empty:
                                revenue_avg_error = revenue_accuracy['Error_Rate'].mean()
                                if revenue_avg_error < 0:
                                    st.info("🏢 **JFEシステムズの特徴**: システム開発業として、プロジェクト進捗により売上が計画を下回る傾向があります。")
                            
                            # 利益率の安定性
                            op_accuracy = accuracy_df[accuracy_df['Metric'] == 'Operating_Profit']
                            if not op_accuracy.empty:
                                op_avg_error = op_accuracy['Error_Rate'].mean()
                                if abs(op_avg_error) < 10:
                                    st.success("💼 **収益安定性**: 営業利益は比較的予想に近く、安定した収益性を保っています。")
                            
                            # 期中上方修正の特徴
                            modification_data = forecast_df[forecast_df['Type'] == '修']
                            if not modification_data.empty:
                                upward_modifications = modification_data[
                                    (modification_data['Revenue'].notna()) & 
                                    (modification_data['Revenue'] > 0)
                                ]
                                if not upward_modifications.empty:
                                    st.info("📈 **期中修正**: 期中での上方修正により、受注環境の改善が見られます。")
                            
                            # 配当の安定性
                            dividend_data = forecast_df[forecast_df['Dividend'].notna() & (forecast_df['Dividend'] > 0)]
                            if not dividend_data.empty:
                                dividend_growth = dividend_data['Dividend'].pct_change().dropna()
                                if dividend_growth.mean() > 0:
                                    st.success("💰 **配当成長**: 継続的な増配により株主還元を強化しています。")
                            
                            # ITサービス業界の特性
                            if avg_abs_error < 15:  # 比較的精度が高い
                                st.info("💻 **事業特性**: ITサービス業として、長期契約により比較的安定した業績予想精度を保っています。")
                        
                        elif ticker == '4767.T':
                            # テー・オー・ダブリューの特徴
                            revenue_accuracy = accuracy_df[accuracy_df['Metric'] == 'Revenue']
                            if not revenue_accuracy.empty:
                                revenue_errors = revenue_accuracy['Error_Rate']
                                revenue_volatility = revenue_errors.std()
                                if revenue_volatility > 10:
                                    st.warning("📢 **広告業界の特性**: 景気変動や顧客予算の影響により、売上予想の精度にばらつきが見られます。")
                            
                            # 利益改善傾向
                            profit_accuracy = accuracy_df[accuracy_df['Metric'] == 'Operating_Profit']
                            if not profit_accuracy.empty:
                                recent_profit_errors = profit_accuracy.tail(3)['Error_Rate']
                                if recent_profit_errors.mean() > 0:
                                    st.success("📈 **利益改善**: 近年の営業利益は予想を上回る傾向にあり、事業効率化が進んでいます。")
                            
                            # 配当政策
                            dividend_data = forecast_df[forecast_df['Dividend'].notna() & (forecast_df['Dividend'] > 0)]
                            if not dividend_data.empty:
                                dividend_stability = dividend_data['Dividend'].std()
                                if dividend_stability < 5:
                                    st.info("💰 **安定配当**: 業績変動にかかわらず、一定水準の配当維持を重視しています。")
                            
                            # 広告・マーケティング業界の特性
                            if avg_abs_error > 15:  # 予想精度のばらつき
                                st.info("📊 **事業特性**: 広告・マーケティング業界として、経済環境や顧客予算の変動により業績予想の難易度が高い業界です。")
            
            with tab3:
                st.write("**業績予想修正履歴詳細データ**")
                st.dataframe(forecast_df, use_container_width=True)
                
                if not accuracy_df.empty:
                    st.write("**予想精度詳細データ**")
                    st.dataframe(accuracy_df, use_container_width=True)
        
        st.write("---")
    
    if fundamental_data is not None:
        # 現在の実績値を取得
        latest_revenue = fundamental_data['売上高'].iloc[-1] / 1e2 if '売上高' in fundamental_data.columns else 0
        latest_profit = fundamental_data['営業利益'].iloc[-1] / 1e2 if '営業利益' in fundamental_data.columns else 0
        
        col_forecast1, col_forecast2 = st.columns(2)
        
        with col_forecast1:
            st.write("**📊 実績値（最新期）**")
            st.write(f"• 売上高: {latest_revenue:.1f}億円")
            st.write(f"• 営業利益: {latest_profit:.1f}億円")
            if latest_revenue > 0:
                current_margin = (latest_profit / latest_revenue) * 100
                st.write(f"• 営業利益率: {current_margin:.1f}%")
        
        with col_forecast2:
            st.write("**🔮 予想値入力**")
            
            # セッションステートで予想値を管理
            forecast_key_revenue = f"forecast_revenue_{ticker}"
            forecast_key_profit = f"forecast_profit_{ticker}"
            
            # 初期値を設定（一度だけ）
            if forecast_key_revenue not in st.session_state:
                st.session_state[forecast_key_revenue] = latest_revenue
            if forecast_key_profit not in st.session_state:
                st.session_state[forecast_key_profit] = max(latest_profit, 1.0)  # 最低1億円
            
            # number_inputのキーは別の名前にする
            forecast_revenue = st.number_input(
                "予想売上高 (億円)",
                min_value=0.0,
                value=float(st.session_state[forecast_key_revenue]),
                step=1.0,
                key=f"summary_input_revenue_{ticker}"
            )
            
            forecast_profit = st.number_input(
                "予想営業利益 (億円)",
                min_value=0.0,
                value=float(st.session_state[forecast_key_profit]),
                step=0.1,
                key=f"summary_input_profit_{ticker}"
            )
            
            # 値が変更された場合にセッションステートを更新
            if forecast_revenue != st.session_state[forecast_key_revenue]:
                st.session_state[forecast_key_revenue] = forecast_revenue
            if forecast_profit != st.session_state[forecast_key_profit]:
                st.session_state[forecast_key_profit] = forecast_profit
            
            # 予想利益率の計算と表示
            if forecast_revenue > 0:
                forecast_margin = (forecast_profit / forecast_revenue) * 100
                
                if forecast_margin > 15:
                    margin_status = "🟢 高収益性"
                elif forecast_margin > 5:
                    margin_status = "🟡 標準的"
                else:
                    margin_status = "🔴 低収益性"
                
                st.metric(
                    "予想営業利益率",
                    f"{forecast_margin:.1f}%",
                    f"{margin_status}"
                )
                
                # 成長率の計算
                if latest_revenue > 0 and latest_profit > 0:
                    revenue_growth = ((forecast_revenue - latest_revenue) / latest_revenue) * 100
                    profit_growth = ((forecast_profit - latest_profit) / latest_profit) * 100
                    
                    st.write("**📈 予想成長率**")
                    st.write(f"• 売上高成長率: {revenue_growth:+.1f}%")
                    st.write(f"• 営業利益成長率: {profit_growth:+.1f}%")
            
            # バリュエーション分析
            if st.button(f"📊 {ticker} バリュエーション分析", key=f"summary_valuation_{ticker}"):
                if forecast_profit > 0:
                    # 簡易的なPER計算（業界平均PER 15倍と仮定）
                    estimated_per = 15
                    estimated_market_cap = forecast_profit * estimated_per
                    current_market_cap = ticker_info.get('marketCap', 0) / 1e8 if ticker_info.get('marketCap') else 0
                    
                    st.success(f"""
                    **バリュエーション分析結果**
                    • 予想営業利益: {forecast_profit:.1f}億円
                    • 想定PER: {estimated_per}倍
                    • 理論時価総額: {estimated_market_cap:.0f}億円
                    • 現在時価総額: {current_market_cap:.0f}億円
                    • 理論株価倍率: {(estimated_market_cap / max(current_market_cap, 1)):.1f}倍
                    """)
    else:
        st.info("財務データが利用できないため、予想値設定はできません。")
    
    # 投資メモ
    st.subheader("📝 統合分析メモ")
    investment_memo = st.text_area(
        "統合分析に基づく投資判断の根拠",
        placeholder="テクニカル分析とファンダメンタル分析の結果を総合した投資判断と根拠を記録...",
        height=100,
        key=f"summary_memo_{ticker}"
    )
    
    # 詳細ファンダメンタル分析
    if fundamental_data is not None:
        st.subheader('🏢 詳細ファンダメンタル分析')
        key_metrics = ['売上高', '営業利益', '当期利益', '総資産', '自己資本']
        available_metrics = [m for m in key_metrics if m in fundamental_data.columns]
        
        if available_metrics:
            selected_metrics = st.multiselect(
                'グラフに表示する指標を選択',
                options=fundamental_data.columns.tolist(),
                default=available_metrics[:3],
                key=f"summary_metrics_{ticker}"
            )
            
            if selected_metrics:
                fig = go.Figure()
                for metric in selected_metrics:
                    fig.add_trace(go.Scatter(
                        x=fundamental_data.index,
                        y=fundamental_data[metric] / 1e2,  # 億円
                        mode='lines+markers',
                        name=metric,
                        line=dict(width=2),
                        marker=dict(size=6)
                    ))
                
                fig.update_layout(
                    title='財務指標の推移',
                    yaxis_title='金額 (億円)',
                    height=400
                )
                st.plotly_chart(fig, use_container_width=True)

# --- Streamlit アプリ本体 ---
st.title('📈 統合株式分析アプリ')
st.caption('テクニカル分析とファンダメンタル分析を統合し、多角的な視点から投資判断をサポートします。')

# --- サイドバー ---
st.sidebar.header('分析条件の設定')

# 利用可能な財務データ銘柄を表示
available_tickers = get_available_financial_tickers()
if available_tickers:
    st.sidebar.success(f'📊 財務データ対応銘柄: {len(available_tickers)}社')
    with st.sidebar.expander("対応銘柄一覧を表示"):
        for ticker in available_tickers:
            company_name = JAPANESE_COMPANY_NAMES.get(ticker, ticker)
            st.write(f"• {ticker} - {company_name}")

# セッションステートの初期化
if 'ticker_selection' not in st.session_state:
    st.session_state.ticker_selection = ', '.join(available_tickers[:5]) if available_tickers else '4816.T, 6357.T, 2428.T'

# 銘柄選択のオプション
col1, col2 = st.sidebar.columns(2)
with col1:
    if st.button('📋 全選択', help='全対応銘柄を選択'):
        st.session_state.ticker_selection = ', '.join(available_tickers)
with col2:
    if st.button('🔄 リセット', help='デフォルトに戻す'):
        st.session_state.ticker_selection = ', '.join(available_tickers[:5]) if available_tickers else '4816.T, 6357.T, 2428.T'

ticker_list_input = st.sidebar.text_area(
    '📊 分析したい銘柄コードを入力（カンマ区切り or 改行）',
    value=st.session_state.ticker_selection,
    height=150,
    help='財務データ対応銘柄：4816.T（東映アニメーション）、6357.T（三精テクノロジーズ）、2428.T（ウェルネット）等\n対応する財務データCSVファイルを自動検索します'
)

# 銘柄リストの処理
tickers = []
for line in ticker_list_input.split('\n'):
    line_tickers = [ticker.strip().upper() for ticker in line.split(',') if ticker.strip()]
    tickers.extend(line_tickers)

# 期間設定
col1, col2 = st.sidebar.columns(2)
with col1:
    start_date = st.date_input('📅 開始日', value=datetime.now() - timedelta(days=365))
with col2:
    end_date = st.date_input('📅 終了日', value=datetime.now())

# 統合分析実行
if st.sidebar.button('🚀 統合分析実行', type="primary"):
    if not tickers:
        st.error('銘柄コードを入力してください。')
    else:
        # --- データ取得と処理 ---
        all_data = {}
        ticker_info_dict = {}
        fundamental_data_dict = {}
        summary_list = []
        
        with st.spinner('各銘柄のデータを取得中...'):
            for ticker in tickers:
                try:
                    # テクニカルデータ取得
                    stock_data = yf.download(ticker, start=start_date, end=end_date, progress=False, auto_adjust=False)
                    if stock_data.empty:
                        st.warning(f'{ticker}: 株価データ取得失敗。スキップします。')
                        continue
                    
                    stock_data = calculate_technicals(stock_data)
                    all_data[ticker] = stock_data
                    
                    # 企業情報を取得
                    ticker_info = yf.Ticker(ticker).info
                    ticker_info_dict[ticker] = ticker_info
                    
                    # ファンダメンタルデータ自動検索
                    csv_file = find_financial_csv(ticker)
                    if csv_file:
                        try:
                            fundamental_data = process_financial_csv(csv_file)
                            if fundamental_data is not None:
                                fundamental_data_dict[ticker] = fundamental_data
                                st.sidebar.success(f'{ticker}: 財務データ読み込み成功 ({csv_file})')
                            else:
                                st.sidebar.warning(f'{ticker}: 財務データ処理失敗')
                        except Exception as e:
                            st.sidebar.warning(f'{ticker}: 財務データ読み込みエラー - {e}')
                    else:
                        st.sidebar.info(f'{ticker}: 対応する財務データCSVが見つかりません')
                    
                    # サマリー情報の作成
                    latest_price = stock_data['Close'].iloc[-1].item()
                    prev_day_price = stock_data['Close'].iloc[-2].item()
                    change = latest_price - prev_day_price
                    change_percent = (change / prev_day_price) * 100 if prev_day_price != 0 else 0
                    
                    # ファンダメンタル情報の追加
                    fundamental_info = ""
                    if ticker in fundamental_data_dict:
                        fund_data = fundamental_data_dict[ticker]
                        if '営業利益' in fund_data.columns and len(fund_data) > 1:
                            latest_profit = fund_data['営業利益'].iloc[-1] / 1e2  # 億円
                            prev_profit = fund_data['営業利益'].iloc[-2] / 1e2
                            profit_growth = ((latest_profit - prev_profit) / prev_profit) * 100 if prev_profit != 0 else 0
                            fundamental_info = f"営業利益: {latest_profit:.0f}億円 ({profit_growth:+.1f}%)"
                        else:
                            fundamental_info = "財務データ利用可能"
                    else:
                        fundamental_info = "財務データなし"
                    
                    summary_list.append({
                        '銘柄コード': ticker,
                        '企業名': get_japanese_company_name(ticker, ticker_info),
                        '最新株価 (円)': f"{latest_price:,.2f}",
                        '前日比 (%)': f"{change_percent:.2f}%",
                        'RSI': f"{stock_data['RSI'].iloc[-1].item():.2f}",
                        '時価総額 (億円)': f"{ticker_info.get('marketCap', 0) / 1e8:,.0f}" if ticker_info.get('marketCap') else 'N/A',
                        'ファンダメンタル': fundamental_info
                    })
                    
                except Exception as e:
                    st.error(f'{ticker}の処理中にエラー: {e}')
        
        if not all_data:
            st.error('取得できた銘柄データがありません。')
            st.stop()
        
        # --- 統合分析結果の表示 ---
        st.success(f'{len(all_data)}銘柄の統合分析が完了しました！')
# --- ダッシュボード用関数 ---
def render_main_dashboard(all_data, ticker_info_dict, fundamental_data_dict, market_indices=None):
    """メインダッシュボードの表示"""
    st.subheader('📈 統合株式分析ダッシュボード')

    # 市場指標表示
    if market_indices and len(market_indices) > 0:
        with st.container(border=True):
            st.subheader('🏛️ 市場指標')
            col_market1, col_market2 = st.columns(2)
            
            with col_market1:
                if '日経平均' in market_indices:
                    nikkei_data = market_indices['日経平均']
                    latest_nikkei = nikkei_data['Close'].iloc[-1]
                    prev_nikkei = nikkei_data['Close'].iloc[-2] if len(nikkei_data) > 1 else latest_nikkei
                    nikkei_change = ((latest_nikkei - prev_nikkei) / prev_nikkei) * 100 if prev_nikkei > 0 else 0
                    
                    st.metric(
                        "📊 日経平均", 
                        f"{latest_nikkei:,.0f}円",
                        f"{nikkei_change:+.2f}%"
                    )
            
            with col_market2:
                if 'TOPIX' in market_indices:
                    topix_data = market_indices['TOPIX']
                    latest_topix = topix_data['Close'].iloc[-1]
                    prev_topix = topix_data['Close'].iloc[-2] if len(topix_data) > 1 else latest_topix
                    topix_change = ((latest_topix - prev_topix) / prev_topix) * 100 if prev_topix > 0 else 0
                    
                    st.metric(
                        "📈 TOPIX", 
                        f"{latest_topix:,.2f}pt",
                        f"{topix_change:+.2f}%"
                    )

    # サマリーメトリクス
    with st.container(border=True):
        st.subheader('🎯 サマリーメトリクス')
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("📊 分析対象銘柄数", len(all_data))
        with col2:
            # 平均RSI計算
            avg_rsi = np.mean([df['RSI'].iloc[-1] for df in all_data.values() if 'RSI' in df.columns])
            st.metric("📈 平均RSI", f"{avg_rsi:.1f}")
        with col3:
            # 上昇銘柄数
            up_count = sum(1 for df in all_data.values() if len(df) > 1 and df['Close'].iloc[-1] > df['Close'].iloc[-2])
            st.metric("🟢 前日比上昇", f"{up_count}銘柄")
        with col4:
            # 下落銘柄数
            down_count = len(all_data) - up_count
            st.metric("🔴 前日比下落", f"{down_count}銘柄")
    
    # 銘柄サマリーテーブル
    with st.container(border=True):
        st.subheader('💼 銘柄サマリー')
        
        summary_data = []
        for ticker, stock_data in all_data.items():
            company_name = get_japanese_company_name(ticker, ticker_info_dict.get(ticker, {}))
            latest_price = stock_data['Close'].iloc[-1]
            prev_price = stock_data['Close'].iloc[-2] if len(stock_data) > 1 else latest_price
            change_pct = ((latest_price - prev_price) / prev_price) * 100 if prev_price > 0 else 0
            rsi = stock_data['RSI'].iloc[-1] if 'RSI' in stock_data.columns else 0
            
            # ファンダメンタル情報
            fund_data = fundamental_data_dict.get(ticker)
            revenue = 0
            profit = 0
            
            if fund_data is not None:
                # 2025年以前の実績データのみを使用
                actual_data = fund_data[fund_data.index.year <= 2025]
                if not actual_data.empty:
                    if '売上高' in actual_data.columns:
                        latest_revenue = actual_data['売上高'].dropna().iloc[-1] if not actual_data['売上高'].dropna().empty else 0
                        revenue = latest_revenue / 1e2 if latest_revenue > 0 else 0
                    
                    if '営業利益' in actual_data.columns:
                        latest_profit = actual_data['営業利益'].dropna().iloc[-1] if not actual_data['営業利益'].dropna().empty else 0
                        profit = latest_profit / 1e2 if latest_profit > 0 else 0
            
            # バリュエーション指標（PER, PBR）
            ticker_info = ticker_info_dict.get(ticker, {})
            per_value = ticker_info.get('trailingPE')
            if per_value is None or per_value <= 0:
                per_value = ticker_info.get('forwardPE')
            per_display = f"{per_value:.2f}" if per_value and per_value > 0 else "N/A"
            
            pbr_value = ticker_info.get('priceToBook')
            pbr_display = f"{pbr_value:.2f}" if pbr_value and pbr_value > 0 else "N/A"
            
            summary_data.append({
                '銘柄コード': ticker,
                '企業名': company_name,
                '最新株価(¥)': f"{latest_price:,.0f}",
                '前日比(%)': f"{change_pct:+.2f}",
                'RSI': f"{rsi:.1f}",
                'PER': per_display,
                'PBR': pbr_display,
                '売上高(億円)': f"{revenue:.1f}" if revenue > 0 else "N/A",
                '営業利益(億円)': f"{profit:.1f}" if profit > 0 else "N/A",
                'アクション': '詳細分析'
            })
        
        summary_df = pd.DataFrame(summary_data)
        
        # 前日比の色付け用の関数
        def color_change_pct(val):
            """前日比の値に基づいて色付けする"""
            try:
                # 文字列から数値を取得（+1.23 や -2.45 の形式）
                if pd.isna(val) or val == '' or val is None:
                    return ''
                
                # 文字列を数値に変換
                if isinstance(val, str):
                    num_val = float(val.replace('+', '').replace('%', ''))
                else:
                    num_val = float(val)
                    
                if num_val > 0:
                    return 'background-color: #ffebee; color: #d32f2f'  # 薄い赤背景、濃い赤文字
                elif num_val < 0:
                    return 'background-color: #e3f2fd; color: #1976d2'  # 薄い青背景、濃い青文字
                else:
                    return 'background-color: #f5f5f5; color: #666666'  # グレー
            except Exception as e:
                return ''
        
        # データフレームの表示（スタイル適用）
        try:
            styled_df = summary_df.style.apply(
                lambda x: [color_change_pct(val) if x.name == '前日比(%)' else '' for val in x], 
                axis=0
            )
        except Exception as e:
            styled_df = summary_df
        
        # インタラクティブなテーブル表示
        try:
            selected_row = st.dataframe(
                styled_df,
                use_container_width=True,
                on_select="rerun",
                selection_mode="single-row"
            )
        except Exception as e:
            st.warning(f"テーブル表示エラー: {str(e)}")
            # フォールバック: 通常のテーブル表示
            st.dataframe(summary_df, use_container_width=True)
            selected_row = None
        
        # 銘柄選択処理
        if selected_row and hasattr(selected_row, 'selection') and selected_row.selection.rows:
            try:
                selected_idx = selected_row.selection.rows[0]
                selected_ticker = summary_df.iloc[selected_idx]['銘柄コード']
                
                col_btn1, col_btn2 = st.columns([1, 4])
                with col_btn1:
                    if st.button(f"📊 {selected_ticker} 詳細分析", use_container_width=True):
                        st.session_state.page = 'detail'
                        st.session_state.selected_ticker = selected_ticker
                        st.rerun()
            except Exception as e:
                st.warning(f"銘柄選択エラー: {str(e)}")
    
    # パフォーマンス比較チャート
    with st.container(border=True):
        st.subheader('📈 パフォーマンス比較')
        
        col_chart1, col_chart2 = st.columns(2)
        
        with col_chart1:
            st.write("**正規化株価推移（初日=100）**")
            if all_data:
                normalized_prices = pd.DataFrame()
                for ticker, df in all_data.items():
                    if not df.empty:
                        normalized_prices[ticker] = (df['Close'] / df['Close'].iloc[0]) * 100

                fig_perf = go.Figure()
                
                # ポートフォリオ平均
                if not normalized_prices.empty:
                    portfolio_avg = normalized_prices.mean(axis=1)
                    fig_perf.add_trace(go.Scatter(
                        x=portfolio_avg.index, 
                        y=portfolio_avg, 
                        mode='lines', 
                        name='ポートフォリオ平均',
                        line=dict(color='blue', width=3)
                    ))
                    
                    # 個別銘柄（薄く表示）
                    for ticker in list(normalized_prices.columns)[:5]:  # 最初の5銘柄のみ
                        fig_perf.add_trace(go.Scatter(
                            x=normalized_prices.index, 
                            y=normalized_prices[ticker], 
                            mode='lines', 
                            name=ticker,
                            line=dict(width=1),
                            opacity=0.4
                        ))
                
                fig_perf.update_layout(height=400, showlegend=True)
                st.plotly_chart(fig_perf, use_container_width=True)
        
        with col_chart2:
            st.write("**RSI分布**")
            rsi_values = [df['RSI'].iloc[-1] for df in all_data.values() if 'RSI' in df.columns]
            if rsi_values:
                fig_rsi = go.Figure(data=[go.Histogram(x=rsi_values, nbinsx=20)])
                fig_rsi.update_layout(
                    xaxis_title='RSI値',
                    yaxis_title='銘柄数',
                    height=400
                )
                # RSIの閾値線
                fig_rsi.add_vline(x=30, line_dash="dash", line_color="green", annotation_text="買われすぎ")
                fig_rsi.add_vline(x=70, line_dash="dash", line_color="red", annotation_text="売られすぎ")
                st.plotly_chart(fig_rsi, use_container_width=True)

def render_detail_page(ticker, stock_data, ticker_info, fundamental_data):
    """個別銘柄詳細ページの表示"""
    company_name = get_japanese_company_name(ticker, ticker_info)
    
    # ヘッダー
    col_header1, col_header2 = st.columns([3, 1])
    with col_header1:
        st.title(f'📊 {company_name} ({ticker})')
    with col_header2:
        if st.button('← ダッシュボードに戻る', use_container_width=True):
            st.session_state.page = 'dashboard'
            st.rerun()
    
    # タブ構造
    tab1, tab2, tab3, tab4, tab5 = st.tabs([
        "📈 概要＆テクニカル",
        "🏢 ファンダメンタル分析", 
        "📊 業績予想精度分析",
        "🔍 株価変動要因分析",
        "🎯 投資判断"
    ])
    
    with tab1:
        render_summary_tab(ticker, stock_data, ticker_info, fundamental_data)
    
    with tab2:
        render_fundamental_tab(ticker, stock_data, fundamental_data)
    
    with tab3:
        render_forecast_tab(ticker)
    
    with tab4:
        render_price_analysis_tab(ticker, stock_data, fundamental_data)
    
    with tab5:
        render_investment_tab(ticker, stock_data, ticker_info, fundamental_data)

def render_summary_tab(ticker, stock_data, ticker_info, fundamental_data):
    """概要＆テクニカルタブの表示"""
    # 主要メトリクス
    with st.container(border=True):
        st.subheader('🎯 主要メトリクス')
        col1, col2, col3, col4, col5 = st.columns(5)
        
        with col1:
            latest_price = stock_data['Close'].iloc[-1]
            st.metric("💰 最新株価", f"¥{latest_price:,.2f}")
        
        with col2:
            prev_price = stock_data['Close'].iloc[-2] if len(stock_data) > 1 else latest_price
            change = latest_price - prev_price
            change_pct = (change / prev_price) * 100 if prev_price > 0 else 0
            st.metric("📈 前日比", f"{change_pct:.2f}%", f"¥{change:+.2f}")
        
        with col3:
            rsi_value = stock_data['RSI'].iloc[-1] if 'RSI' in stock_data.columns else 0
            rsi_signal = "🔥過熱" if rsi_value > 70 else "❄️売られすぎ" if rsi_value < 30 else "😐中立"
            st.metric("📊 RSI", f"{rsi_value:.1f}", rsi_signal)
        
        with col4:
            if fundamental_data is not None and not fundamental_data.empty and '売上高' in fundamental_data.columns:
                # 2025年以前の実績データを取得
                revenue_series = fundamental_data['売上高'].dropna()
                try:
                    revenue_series.index = pd.to_datetime(revenue_series.index)
                    revenue_series = revenue_series[revenue_series.index.year <= 2025]
                except:
                    pass
                if not revenue_series.empty:
                    # 百万円を億円に変換（1e2で割る）
                    latest_revenue = revenue_series.iloc[-1] / 1e2
                    st.metric("📊 売上高", f"{latest_revenue:.1f}億円")
                else:
                    st.metric("📊 売上高", "データなし")
            else:
                st.metric("📊 売上高", "データなし")
        
        with col5:
            if fundamental_data is not None and not fundamental_data.empty and '営業利益' in fundamental_data.columns:
                # 2025年以前の実績データを取得
                profit_series = fundamental_data['営業利益'].dropna()
                try:
                    profit_series.index = pd.to_datetime(profit_series.index)
                    profit_series = profit_series[profit_series.index.year <= 2025]
                except:
                    pass
                if not profit_series.empty:
                    # 百万円を億円に変換（1e2で割る）
                    latest_profit = profit_series.iloc[-1] / 1e2
                    st.metric("💼 営業利益", f"{latest_profit:.1f}億円")
                else:
                    st.metric("💼 営業利益", "データなし")
            else:
                st.metric("💼 営業利益", "データなし")
    
    # バリュエーション指標セクション
    with st.container(border=True):
        st.subheader('📊 バリュエーション指標')
        
        # バリュエーション指標を取得
        valuation_metrics = get_valuation_metrics(ticker_info, fundamental_data)
        
        col_val1, col_val2, col_val3, col_val4 = st.columns(4)
        
        with col_val1:
            per_value = valuation_metrics.get('PER')
            if per_value is not None:
                # PER評価（一般的な目安：15倍が標準）
                if per_value < 10:
                    per_delta = "割安"
                    per_delta_color = "normal"
                elif per_value < 20:
                    per_delta = "標準"
                    per_delta_color = "off"
                else:
                    per_delta = "割高"
                    per_delta_color = "inverse"
                st.metric("📈 PER", f"{per_value:.1f}倍", per_delta, delta_color=per_delta_color)
            else:
                st.metric("📈 PER", "データなし")
        
        with col_val2:
            pbr_value = valuation_metrics.get('PBR')
            if pbr_value is not None:
                # PBR評価（一般的な目安：1倍が理論値）
                if pbr_value < 0.8:
                    pbr_delta = "割安"
                    pbr_delta_color = "normal"
                elif pbr_value < 1.5:
                    pbr_delta = "標準"
                    pbr_delta_color = "off"
                else:
                    pbr_delta = "割高"
                    pbr_delta_color = "inverse"
                st.metric("📊 PBR", f"{pbr_value:.2f}倍", pbr_delta, delta_color=pbr_delta_color)
            else:
                st.metric("📊 PBR", "データなし")
        
        with col_val3:
            roe_value = valuation_metrics.get('ROE')
            if roe_value is not None:
                # ROE評価（一般的な目安：8%以上が良好）
                if roe_value >= 15:
                    roe_delta = "優秀"
                    roe_delta_color = "normal"
                elif roe_value >= 8:
                    roe_delta = "良好"
                    roe_delta_color = "normal"
                elif roe_value >= 5:
                    roe_delta = "標準"
                    roe_delta_color = "off"
                else:
                    roe_delta = "低水準"
                    roe_delta_color = "inverse"
                st.metric("💼 ROE", f"{roe_value:.1f}%", roe_delta, delta_color=roe_delta_color)
            else:
                st.metric("💼 ROE", "データなし")
        
        with col_val4:
            dividend_yield = valuation_metrics.get('配当利回り')
            if dividend_yield is not None:
                # 配当利回り評価（一般的な目安：3%以上が高配当）
                if dividend_yield >= 4:
                    div_delta = "高配当"
                    div_delta_color = "normal"
                elif dividend_yield >= 2:
                    div_delta = "標準"
                    div_delta_color = "off"
                elif dividend_yield > 0:
                    div_delta = "低配当"
                    div_delta_color = "inverse"
                else:
                    div_delta = "無配"
                    div_delta_color = "inverse"
                st.metric("💰 配当利回り", f"{dividend_yield:.2f}%", div_delta, delta_color=div_delta_color)
            else:
                st.metric("💰 配当利回り", "データなし")
    
    # チャート表示
    col_chart1, col_chart2 = st.columns(2)
    
    with col_chart1:
        with st.container(border=True):
            st.subheader('📈 ローソク足チャート')
            fig_candle = create_candlestick_chart(stock_data, ticker, get_japanese_company_name(ticker, ticker_info))
            fig_candle.update_layout(height=500)
            st.plotly_chart(fig_candle, use_container_width=True)
    
    with col_chart2:
        with st.container(border=True):
            st.subheader('📊 RSI推移')
            fig_rsi = create_rsi_chart(stock_data, ticker)
            fig_rsi.update_layout(height=500)
            st.plotly_chart(fig_rsi, use_container_width=True)
    
    # ボラティリティ分析セクション
    st.markdown("---")
    with st.container(border=True):
        st.subheader('📈 ボラティリティ分析（過去1年間）')
        
        # ボラティリティメトリクス計算
        vol_metrics = calculate_volatility_metrics(stock_data)
        
        if vol_metrics:
            # ボラティリティ指標表示
            col_vol1, col_vol2, col_vol3, col_vol4 = st.columns(4)
            
            with col_vol1:
                st.metric(
                    "年間ボラティリティ", 
                    f"{vol_metrics['annual_volatility']:.1%}",
                    help="株価の年間変動率の標準偏差"
                )
            
            with col_vol2:
                st.metric(
                    "月間ボラティリティ", 
                    f"{vol_metrics['monthly_volatility']:.1%}",
                    help="株価の月間変動率の標準偏差"
                )
            
            with col_vol3:
                st.metric(
                    "VaR (95%信頼区間)",
                    f"{vol_metrics['var_95']:.1%}",
                    help="5%の確率で超える1日の損失率"
                )
            
            with col_vol4:
                st.metric(
                    "VaR (99%信頼区間)",
                    f"{vol_metrics['var_99']:.1%}",
                    help="1%の確率で超える1日の損失率"
                )
            
            # ボラティリティ推移チャート
            col_vol_chart1, col_vol_chart2 = st.columns(2)
            
            with col_vol_chart1:
                st.write("**ローリングボラティリティ推移（30日）**")
                fig_vol = create_rolling_volatility_chart(stock_data, ticker, window=30)
                st.plotly_chart(fig_vol, use_container_width=True)
            
            with col_vol_chart2:
                st.write("**リターン分布ヒストグラム**")
                fig_hist = create_returns_histogram(vol_metrics['daily_returns'], ticker)
                st.plotly_chart(fig_hist, use_container_width=True)
            
            # 次営業日価格予測
            st.markdown("---")
            st.write("**📊 次営業日価格予測（ボラティリティベース）**")
            
            # 信頼区間ごとの予測を計算
            prediction_68 = predict_next_day_price(vol_metrics, confidence_level=0.68)
            prediction_95 = predict_next_day_price(vol_metrics, confidence_level=0.95)
            prediction_997 = predict_next_day_price(vol_metrics, confidence_level=0.997)
            
            col_pred1, col_pred2, col_pred3, col_pred4 = st.columns(4)
            
            with col_pred1:
                current_price = vol_metrics['close_prices'].iloc[-1]
                st.metric("現在価格", f"¥{current_price:,.0f}")
            
            with col_pred2:
                if prediction_68:
                    expected_price = prediction_68['expected_price']
                    change_pct = (expected_price - current_price) / current_price
                    st.metric(
                        "期待価格", 
                        f"¥{expected_price:,.0f}",
                        f"{change_pct:+.2%}"
                    )
            
            with col_pred3:
                if prediction_95:
                    st.metric(
                        "価格範囲 (95%)", 
                        f"¥{prediction_95['lower_bound']:,.0f} - ¥{prediction_95['upper_bound']:,.0f}",
                        help="95%の確率でこの範囲内"
                    )
            
            with col_pred4:
                if prediction_997:
                    st.metric(
                        "価格範囲 (99.7%)", 
                        f"¥{prediction_997['lower_bound']:,.0f} - ¥{prediction_997['upper_bound']:,.0f}",
                        help="99.7%の確率でこの範囲内"
                    )

def generate_financial_analysis_comments(fundamental_data, ticker):
    """財務データから自動的に分析コメントを生成"""
    try:
        comments = []
        comments.append("**📊 財務データから読み取れる企業特徴:**\n")
        
        # 売上高分析
        if '売上高' in fundamental_data.columns:
            revenue_data = fundamental_data['売上高'].dropna()
            if len(revenue_data) > 1:
                # 成長率計算
                latest_revenue = revenue_data.iloc[-1] / 1e2  # 億円換算
                prev_revenue = revenue_data.iloc[-2] / 1e2 if len(revenue_data) > 1 else latest_revenue
                growth_rate = ((latest_revenue - prev_revenue) / prev_revenue * 100) if prev_revenue > 0 else 0
                
                comments.append(f"• **売上高**: {latest_revenue:.1f}億円")
                if growth_rate > 10:
                    comments.append(f"  - 前年比 {growth_rate:+.1f}% の高成長 🚀")
                elif growth_rate > 3:
                    comments.append(f"  - 前年比 {growth_rate:+.1f}% の堅調な成長 📈")
                elif growth_rate > 0:
                    comments.append(f"  - 前年比 {growth_rate:+.1f}% の微増成長 🔄")
                elif growth_rate > -5:
                    comments.append(f"  - 前年比 {growth_rate:+.1f}% の軽微な減少 📉")
                else:
                    comments.append(f"  - 前年比 {growth_rate:+.1f}% の大幅減少 ⚠️")
                
                # 売上規模分析
                if latest_revenue > 1000:
                    comments.append("  - 大企業規模（売上1000億円超）")
                elif latest_revenue > 100:
                    comments.append("  - 中堅企業規模（売上100億円台）")
                else:
                    comments.append("  - 中小企業規模（売上100億円未満）")
        
        # 営業利益分析
        if '営業利益' in fundamental_data.columns and '売上高' in fundamental_data.columns:
            profit_data = fundamental_data['営業利益'].dropna()
            revenue_data = fundamental_data['売上高'].dropna()
            
            if len(profit_data) > 0 and len(revenue_data) > 0:
                latest_profit = profit_data.iloc[-1] / 1e2  # 億円換算
                latest_revenue = revenue_data.iloc[-1] / 1e2
                margin = (latest_profit / latest_revenue * 100) if latest_revenue > 0 else 0
                
                comments.append(f"\n• **営業利益**: {latest_profit:.1f}億円")
                comments.append(f"• **営業利益率**: {margin:.1f}%")
                
                if margin > 15:
                    comments.append("  - 非常に高い収益性 ⭐⭐⭐")
                elif margin > 10:
                    comments.append("  - 高い収益性 ⭐⭐")
                elif margin > 5:
                    comments.append("  - 標準的な収益性 ⭐")
                elif margin > 0:
                    comments.append("  - 低い収益性 ⚠️")
                else:
                    comments.append("  - 営業赤字 🔴")
                
                # 利益成長率
                if len(profit_data) > 1:
                    prev_profit = profit_data.iloc[-2] / 1e2
                    profit_growth = ((latest_profit - prev_profit) / prev_profit * 100) if prev_profit != 0 else 0
                    
                    if profit_growth > 20:
                        comments.append(f"  - 利益成長率 {profit_growth:+.1f}% の急成長 🚀")
                    elif profit_growth > 10:
                        comments.append(f"  - 利益成長率 {profit_growth:+.1f}% の好調な成長 📈")
                    elif profit_growth > 0:
                        comments.append(f"  - 利益成長率 {profit_growth:+.1f}% の堅調な成長 🔄")
                    else:
                        comments.append(f"  - 利益成長率 {profit_growth:+.1f}% の減益 📉")
        
        # 時系列トレンド分析
        comments.append(f"\n• **トレンド分析**:")
        data_years = len(fundamental_data)
        if data_years >= 3:
            comments.append("  - 3年以上の財務履歴があり、トレンド分析が可能")
        else:
            comments.append("  - 財務履歴が短く、長期トレンドの評価は困難")
        
        # 投資観点コメント
        comments.append(f"\n• **投資判断の観点**:")
        if '売上高' in fundamental_data.columns and '営業利益' in fundamental_data.columns:
            revenue_data = fundamental_data['売上高'].dropna()
            profit_data = fundamental_data['営業利益'].dropna()
            
            if len(revenue_data) > 1 and len(profit_data) > 1:
                latest_revenue = revenue_data.iloc[-1] / 1e2
                latest_profit = profit_data.iloc[-1] / 1e2
                margin = (latest_profit / latest_revenue * 100) if latest_revenue > 0 else 0
                
                if margin > 10 and latest_revenue > 100:
                    comments.append("  - 規模と収益性を兼ね備えた投資候補 ✅")
                elif margin > 5:
                    comments.append("  - 安定した収益基盤を持つ企業 🔍")
                else:
                    comments.append("  - 収益改善余地のある企業 ⚠️")
        
        return "\n".join(comments)
        
    except Exception as e:
        return f"**分析エラー**: 財務データの分析中にエラーが発生しました: {str(e)}"

def render_fundamental_tab(ticker, stock_data, fundamental_data):
    """ファンダメンタル分析タブの表示"""
    if fundamental_data is not None and not fundamental_data.empty:
        # 財務推移チャート
        with st.container(border=True):
            st.subheader('💹 財務指標推移')
            
            col_fund1, col_fund2 = st.columns(2)
            
            with col_fund1:
                st.write("**売上高推移**")
                if '売上高' in fundamental_data.columns:
                    fig_revenue = go.Figure()
                    fig_revenue.add_trace(go.Scatter(
                        x=fundamental_data.index, 
                        y=fundamental_data['売上高'] / 1e2, 
                        mode='lines+markers',
                        name='売上高',
                        line=dict(color='blue', width=3)
                    ))
                    fig_revenue.update_layout(
                        yaxis_title='売上高 (億円)',
                        height=300
                    )
                    st.plotly_chart(fig_revenue, use_container_width=True)
            
            with col_fund2:
                st.write("**営業利益推移**")
                if '営業利益' in fundamental_data.columns:
                    fig_profit = go.Figure()
                    fig_profit.add_trace(go.Scatter(
                        x=fundamental_data.index, 
                        y=fundamental_data['営業利益'] / 1e2, 
                        mode='lines+markers',
                        name='営業利益',
                        line=dict(color='green', width=3)
                    ))
                    fig_profit.update_layout(
                        yaxis_title='営業利益 (億円)',
                        height=300
                    )
                    st.plotly_chart(fig_profit, use_container_width=True)
        
        # 予想値入力セクション
        with st.container(border=True):
            st.subheader('🔮 業績予想入力')
            render_forecast_input(ticker, fundamental_data)
        
        # 財務データテーブル
        with st.container(border=True):
            st.subheader('📋 財務データ詳細')
            st.dataframe(fundamental_data, use_container_width=True)
            
            # 財務データ自動分析コメント
            st.markdown("---")
            st.subheader('🤖 AI分析コメント')
            auto_analysis = generate_financial_analysis_comments(fundamental_data, ticker)
            st.markdown(auto_analysis)
            
            # ユーザー編集可能な分析メモ
            st.markdown("---")
            st.subheader('📝 あなたの分析メモ (編集可能)')
            
            # セッションステートでメモを管理
            memo_key = f"financial_memo_{ticker}"
            if memo_key not in st.session_state:
                st.session_state[memo_key] = ""
            
            # テキストエリアで編集可能なメモ
            user_memo = st.text_area(
                "財務データから読み取れる企業の特徴や投資判断をメモしてください：",
                value=st.session_state[memo_key],
                height=200,
                placeholder="""例：
• 売上成長率が安定している
• 営業利益率が改善傾向
• 2024年の大幅増収は一過性の要因か継続性があるか要注意
• 競合他社と比較して利益率が高い
• 設備投資の増加が将来の成長につながる可能性
""",
                key=f"fundamental_memo_input_{ticker}"
            )
            
            # メモを保存
            if st.button("💾 分析メモを保存", key=f"save_fundamental_memo_{ticker}"):
                st.session_state[memo_key] = user_memo
                st.success("✅ 分析メモを保存しました！")
            
            # メモをクリア
            col_clear1, col_clear2 = st.columns([1, 4])
            with col_clear1:
                if st.button("🗑️ メモをクリア", key=f"clear_fundamental_memo_{ticker}"):
                    st.session_state[memo_key] = ""
                    st.rerun()
    else:
        st.info("💡 このティッカーのファンダメンタルデータは利用できません。")
    
    # バリュエーション指標の解説セクション
    with st.expander("主要なバリュエーション指標の解説 💡"):
        st.markdown("""
        ### 📈 PER（株価収益率 / Price Earnings Ratio）
        
        **定義**: 株価が1株当たり純利益の何倍かを示す指標
        
        $$\\text{PER} = \\frac{\\text{株価}}{\\text{1株当たり純利益（EPS）}}$$
        
        **目安**:
        - **10倍未満**: 割安とされることが多い
        - **10-20倍**: 一般的な水準
        - **20倍超**: 割高とされることが多い
        
        **注意点**: 業界によって適正水準が異なります。成長企業は高PERでも正当化される場合があります。
        
        ---
        
        ### 📊 PBR（株価純資産倍率 / Price Book-value Ratio）
        
        **定義**: 株価が1株当たり純資産の何倍かを示す指標
        
        $$\\text{PBR} = \\frac{\\text{株価}}{\\text{1株当たり純資産（BPS）}}$$
        
        **目安**:
        - **1倍未満**: 理論的に割安（解散価値を下回る）
        - **1-1.5倍**: 適正水準
        - **1.5倍超**: 割高の可能性
        
        **注意点**: 資産の質や収益性も考慮する必要があります。
        
        ---
        
        ### 💼 ROE（自己資本利益率 / Return On Equity）
        
        **定義**: 自己資本に対してどれだけの利益を上げたかを示す指標
        
        $$\\text{ROE} = \\frac{\\text{当期純利益}}{\\text{自己資本}} \\times 100$$
        
        **目安**:
        - **15%以上**: 優秀
        - **8-15%**: 良好
        - **5-8%**: 標準
        - **5%未満**: 低水準
        
        **注意点**: 高ROEが借入による場合は注意が必要です。持続可能性も重要です。
        
        ---
        
        ### 💰 配当利回り（Dividend Yield）
        
        **定義**: 株価に対する年間配当金の割合
        
        $$\\text{配当利回り} = \\frac{\\text{年間配当金}}{\\text{株価}} \\times 100$$
        
        **目安**:
        - **4%以上**: 高配当
        - **2-4%**: 標準的配当
        - **2%未満**: 低配当
        - **0%**: 無配当（成長投資重視）
        
        **注意点**: 高配当が業績悪化による株価下落の結果である可能性もあります。配当の持続可能性を確認することが重要です。
        
        ---
        
        ### 🔍 総合的な判断のポイント
        
        1. **単一指標に依存しない**: 複数の指標を組み合わせて判断
        2. **業界比較**: 同業他社との比較が重要
        3. **時系列分析**: 過去の推移も確認
        4. **定性要因**: 経営方針、市場環境、競合状況なども考慮
        5. **将来性**: 過去の実績だけでなく将来の成長性も評価
        """)

def render_forecast_input(ticker, fundamental_data):
    """予想値入力セクション"""
    if fundamental_data is not None and not fundamental_data.empty:
        # 最新の有効な実績データを取得（予想データを除く）
        if '売上高' in fundamental_data.columns:
            revenue_series = fundamental_data['売上高'].dropna()
            # 2025年以前のデータを実績とみなす（インデックスを日付に変換）
            try:
                # インデックスが日付文字列の場合
                revenue_series.index = pd.to_datetime(revenue_series.index)
                revenue_series = revenue_series[revenue_series.index.year <= 2025]
            except:
                # インデックスが既に日付の場合またはその他の形式
                pass
            # 百万円を億円に変換（1e2で割る）
            latest_revenue = revenue_series.iloc[-1] / 1e2 if not revenue_series.empty else 0
        else:
            latest_revenue = 0
            
        if '営業利益' in fundamental_data.columns:
            profit_series = fundamental_data['営業利益'].dropna()
            # 2025年以前のデータを実績とみなす（インデックスを日付に変換）
            try:
                # インデックスが日付文字列の場合
                profit_series.index = pd.to_datetime(profit_series.index)
                profit_series = profit_series[profit_series.index.year <= 2025]
            except:
                # インデックスが既に日付の場合またはその他の形式
                pass
            # 百万円を億円に変換（1e2で割る）
            latest_profit = profit_series.iloc[-1] / 1e2 if not profit_series.empty else 0
        else:
            latest_profit = 0
        
        col_current, col_forecast = st.columns(2)
        
        with col_current:
            st.write("**📊 現在の実績値**")
            st.write(f"• 売上高: {latest_revenue:.1f}億円")
            st.write(f"• 営業利益: {latest_profit:.1f}億円")
            if latest_revenue > 0:
                current_margin = (latest_profit / latest_revenue) * 100
                st.write(f"• 営業利益率: {current_margin:.1f}%")
        
        with col_forecast:
            st.write("**🔮 予想値入力**")
            
            # セッションステートで予想値を管理
            forecast_key_revenue = f"forecast_revenue_{ticker}"
            forecast_key_profit = f"forecast_profit_{ticker}"
            
            # 初期値を設定（一度だけ）
            if forecast_key_revenue not in st.session_state:
                # 売上高のデフォルト値：最新実績値、またはnanの場合は100億円
                default_revenue = latest_revenue if not pd.isna(latest_revenue) and latest_revenue > 0 else 100.0
                st.session_state[forecast_key_revenue] = default_revenue
            if forecast_key_profit not in st.session_state:
                # 営業利益のデフォルト値：最新実績値、またはnanの場合は5億円
                default_profit = latest_profit if not pd.isna(latest_profit) and latest_profit > 0 else 5.0
                st.session_state[forecast_key_profit] = default_profit
            
            forecast_revenue = st.number_input(
                "予想売上高 (億円)",
                min_value=0.0,
                value=float(st.session_state[forecast_key_revenue]),
                step=1.0,
                key=f"forecast_revenue_{ticker}"
            )
            
            forecast_profit = st.number_input(
                "予想営業利益 (億円)", 
                min_value=0.0,
                value=float(st.session_state[forecast_key_profit]),
                step=0.1,
                key=f"forecast_profit_{ticker}"
            )
            
            # 値が変更された場合にセッションステートを更新
            if forecast_revenue != st.session_state[forecast_key_revenue]:
                st.session_state[forecast_key_revenue] = forecast_revenue
            if forecast_profit != st.session_state[forecast_key_profit]:
                st.session_state[forecast_key_profit] = forecast_profit
            
            # 予想利益率の計算
            if forecast_revenue > 0:
                forecast_margin = (forecast_profit / forecast_revenue) * 100
                
                # 異常値のチェック（1000%を超える場合は表示しない）
                if forecast_margin > 1000:
                    st.warning("⚠️ 予想営業利益率が異常に高くなっています。売上高と営業利益の値を確認してください。")
                    st.metric("予想営業利益率", "計算不可", "📊 要確認")
                else:
                    if forecast_margin > 15:
                        margin_status = "🟢 高収益性"
                    elif forecast_margin > 5:
                        margin_status = "🟡 標準的" 
                    else:
                        margin_status = "🔴 低収益性"
                    
                    st.metric("予想営業利益率", f"{forecast_margin:.1f}%", margin_status)
            else:
                st.metric("予想営業利益率", "計算不可", "📊 売上高を入力してください")

def render_forecast_tab(ticker):
    """業績予想精度分析タブの表示"""
    # 対応銘柄の業績予想履歴分析
    forecast_data = None
    company_display = ""
    
    if ticker == '6357.T':
        forecast_data = FORECAST_TEXT_6357
        company_display = "三精テクノロジーズ"
    elif ticker == '4816.T':
        forecast_data = FORECAST_TEXT_4816
        company_display = "東映アニメーション"
    elif ticker == '2991.T':
        forecast_data = FORECAST_TEXT_2991
        company_display = "ランドネット"
    elif ticker == '7564.T':
        forecast_data = FORECAST_TEXT_7564
        company_display = "ワークマン"
    elif ticker == '7711.T':
        forecast_data = FORECAST_TEXT_7711
        company_display = "助川電気工業"
    elif ticker == '6405.T':
        forecast_data = FORECAST_TEXT_6405
        company_display = "鈴茂器工"
    elif ticker == '2428.T':
        forecast_data = FORECAST_TEXT_2428
        company_display = "ウェルネット"
    elif ticker == '6231.T':
        forecast_data = FORECAST_TEXT_6231
        company_display = "木村工機"
    elif ticker == '6855.T':
        forecast_data = FORECAST_TEXT_6855
        company_display = "日本電子材料"
    elif ticker == '4832.T':
        forecast_data = FORECAST_TEXT_4832
        company_display = "JFEシステムズ"
    elif ticker == '4767.T':
        forecast_data = FORECAST_TEXT_4767
        company_display = "テー・オー・ダブリュー"
    
    if forecast_data:
        with st.container(border=True):
            st.subheader(f"📊 {company_display} 業績予想修正履歴分析")
            
            # 業績予想履歴データの解析
            forecast_df = parse_forecast_history(forecast_data)
            
            if not forecast_df.empty:
                # サブタブで分析結果を表示
                subtab1, subtab2, subtab3 = st.tabs(["📈 予想vs実績推移", "🎯 予想精度分析", "📋 詳細データ"])
                
                with subtab1:
                    st.write("**業績予想と実績の推移**")
                    accuracy_df = analyze_forecast_accuracy(forecast_df)
                    charts = create_forecast_analysis_charts(forecast_df, accuracy_df)
                    
                    if 'trend' in charts:
                        st.plotly_chart(charts['trend'], use_container_width=True)
                
                with subtab2:
                    accuracy_df = analyze_forecast_accuracy(forecast_df)
                    if not accuracy_df.empty:
                        st.write("**予想精度サマリー**")
                        # 精度分析の詳細表示
                        render_forecast_accuracy_analysis(accuracy_df, forecast_df, ticker)
                    else:
                        st.info("予想精度の分析データが不十分です。")
                
                with subtab3:
                    st.write("**業績予想修正履歴詳細データ**")
                    st.dataframe(forecast_df, use_container_width=True)
            else:
                st.warning("⚠️ 業績予想データの解析に失敗しました。データ形式を確認してください。")
    else:
        st.info("💡 このティッカーの業績予想修正履歴データはまだ対応していません。")

def render_price_analysis_tab(ticker, stock_data, fundamental_data):
    """株価変動要因分析タブの表示"""
    with st.container(border=True):
        st.subheader('🔍 株価変動要因分析')
        
        # 株価変動要因の分析を実行
        price_factors = analyze_price_movement_factors(stock_data, fundamental_data, ticker)
        
        if price_factors:
            st.write("**最近の主要な株価変動とその要因**")
            
            # 上昇と下落を分けて表示
            upward_moves = [move for move in price_factors if move['Move_Type'] == '上昇']
            downward_moves = [move for move in price_factors if move['Move_Type'] == '下落']
            
            col_up, col_down = st.columns(2)
            
            with col_up:
                with st.container(border=True):
                    st.write("**🟢 上昇要因分析**")
                    if upward_moves:
                        for i, move in enumerate(upward_moves[:3]):
                            with st.expander(f"📈 {move['Date']} ({move['Move_Percent']})"):
                                st.write(f"**価格**: ¥{move['Price']:,.2f}")
                                st.write(f"**出来高**: {move['Volume']:,}")
                                
                                if move['Technical_Factors']:
                                    st.write("**テクニカル要因**:")
                                    for factor in move['Technical_Factors']:
                                        st.write(f"• {factor}")
                                
                                if move['Fundamental_Factors']:
                                    st.write("**ファンダメンタル要因**:")
                                    for factor in move['Fundamental_Factors']:
                                        st.write(f"• {factor}")
                                
                                if move['Sector_Factors']:
                                    st.write("**業界特有要因**:")
                                    for factor in move['Sector_Factors']:
                                        st.write(f"• {factor}")
                    else:
                        st.info("大きな上昇は確認されていません")
            
            with col_down:
                with st.container(border=True):
                    st.write("**🔴 下落要因分析**")
                    if downward_moves:
                        for i, move in enumerate(downward_moves[:3]):
                            with st.expander(f"📉 {move['Date']} ({move['Move_Percent']})"):
                                st.write(f"**価格**: ¥{move['Price']:,.2f}")
                                st.write(f"**出来高**: {move['Volume']:,}")
                                
                                if move['Technical_Factors']:
                                    st.write("**テクニカル要因**:")
                                    for factor in move['Technical_Factors']:
                                        st.write(f"• {factor}")
                                
                                if move['Fundamental_Factors']:
                                    st.write("**ファンダメンタル要因**:")
                                    for factor in move['Fundamental_Factors']:
                                        st.write(f"• {factor}")
                                
                                if move['Sector_Factors']:
                                    st.write("**業界特有要因**:")
                                    for factor in move['Sector_Factors']:
                                        st.write(f"• {factor}")
                    else:
                        st.info("大きな下落は確認されていません")
            
            # 要因サマリー
            with st.container(border=True):
                st.write("**📊 要因サマリー**")
                render_factor_summary(price_factors)
        else:
            st.info("大きな株価変動は確認されていません（5%以上の変動を対象）")

def render_factor_summary(price_factors):
    """要因サマリーの表示"""
    all_technical = []
    all_fundamental = []
    all_sector = []
    
    for move in price_factors:
        all_technical.extend(move['Technical_Factors'])
        all_fundamental.extend(move['Fundamental_Factors'])
        all_sector.extend(move['Sector_Factors'])
    
    col_summary1, col_summary2, col_summary3 = st.columns(3)
    
    with col_summary1:
        st.write("**主要テクニカル要因**")
        technical_counts = pd.Series(all_technical).value_counts()
        if not technical_counts.empty:
            for factor, count in technical_counts.head(3).items():
                st.write(f"• {factor} ({count}回)")
        else:
            st.write("• 特徴的な要因なし")
    
    with col_summary2:
        st.write("**主要ファンダメンタル要因**")
        fundamental_counts = pd.Series(all_fundamental).value_counts()
        if not fundamental_counts.empty:
            for factor, count in fundamental_counts.head(3).items():
                st.write(f"• {factor} ({count}回)")
        else:
            st.write("• 特徴的な要因なし")
    
    with col_summary3:
        st.write("**主要業界要因**")
        sector_counts = pd.Series(all_sector).value_counts()
        if not sector_counts.empty:
            for factor, count in sector_counts.head(3).items():
                st.write(f"• {factor} ({count}回)")
        else:
            st.write("• 特徴的な要因なし")

def render_investment_tab(ticker, stock_data, ticker_info, fundamental_data):
    """投資判断タブの表示"""
    # 統合投資判断
    with st.container(border=True):
        st.subheader('🎯 統合投資判断')
        
        col_tech, col_fund = st.columns(2)
        
        with col_tech:
            st.write("**📈 テクニカル分析シグナル**")
            render_technical_signals(stock_data)
        
        with col_fund:
            st.write("**🏢 ファンダメンタル分析シグナル**")
            render_fundamental_signals(fundamental_data)
    
    # 投資判断ボタン
    with st.container(border=True):
        st.subheader('🎯 投資判断')
        col1, col2, col3 = st.columns(3)
        
        company_name = get_japanese_company_name(ticker, ticker_info)
        
        with col1:
            if st.button(f"🟢 {ticker} 買い推奨", key=f"investment_buy_{ticker}", use_container_width=True):
                st.success(f"{company_name} を買い推奨として記録")
        
        with col2:
            if st.button(f"🟡 {ticker} 様子見", key=f"investment_hold_{ticker}", use_container_width=True):
                st.warning(f"{company_name} を様子見として記録")
        
        with col3:
            if st.button(f"🔴 {ticker} 売り推奨", key=f"investment_sell_{ticker}", use_container_width=True):
                st.error(f"{company_name} を売り推奨として記録")
    
    # 投資メモ
    with st.container(border=True):
        st.subheader("📝 投資分析メモ")
        memo_key = f"investment_memo_{ticker}"
        
        investment_memo = st.text_area(
            "投資判断の根拠やメモを記録:",
            height=150,
            key=memo_key,
            placeholder="テクニカル分析とファンダメンタル分析の結果を総合した投資判断と根拠を記録..."
        )
        
        if st.button("💾 メモを保存", key=f"save_investment_memo_{ticker}"):
            st.success("投資メモが保存されました！")

def render_technical_signals(stock_data):
    """テクニカルシグナルの表示"""
    rsi = stock_data['RSI'].iloc[-1] if 'RSI' in stock_data.columns else 50
    
    if rsi > 70:
        st.error("🔴 RSI売りシグナル（過熱状態）")
    elif rsi < 30:
        st.success("🟢 RSI買いシグナル（売られすぎ）")
    else:
        st.info("🟡 RSI中立（様子見）")
    
    # 移動平均線シグナル
    if 'MA20' in stock_data.columns and 'MA50' in stock_data.columns:
        current_price = stock_data['Close'].iloc[-1]
        ma20 = stock_data['MA20'].iloc[-1]
        ma50 = stock_data['MA50'].iloc[-1]
        
        if current_price > ma20 > ma50:
            st.success("🟢 移動平均線上昇トレンド")
        elif current_price < ma20 < ma50:
            st.error("🔴 移動平均線下降トレンド")
        else:
            st.warning("🟡 移動平均線レンジ相場")

def render_fundamental_signals(fundamental_data):
    """ファンダメンタルシグナルの表示"""
    if fundamental_data is not None and not fundamental_data.empty:
        # 売上成長率
        if '売上高' in fundamental_data.columns and len(fundamental_data) > 1:
            latest_revenue = fundamental_data['売上高'].iloc[-1]
            prev_revenue = fundamental_data['売上高'].iloc[-2]
            revenue_growth = ((latest_revenue - prev_revenue) / prev_revenue) * 100 if prev_revenue > 0 else 0
            
            if revenue_growth > 10:
                st.success(f"🟢 売上高成長: +{revenue_growth:.1f}%")
            elif revenue_growth > 0:
                st.info(f"🟡 売上高微増: +{revenue_growth:.1f}%")
            else:
                st.error(f"🔴 売上高減少: {revenue_growth:.1f}%")
        
        # 営業利益率
        if '売上高' in fundamental_data.columns and '営業利益' in fundamental_data.columns:
            latest_revenue = fundamental_data['売上高'].iloc[-1]
            latest_profit = fundamental_data['営業利益'].iloc[-1]
            
            if latest_revenue > 0:
                margin = (latest_profit / latest_revenue) * 100
                
                if margin > 15:
                    st.success(f"🟢 高収益性: {margin:.1f}%")
                elif margin > 5:
                    st.info(f"🟡 標準的: {margin:.1f}%")
                else:
                    st.error(f"🔴 低収益性: {margin:.1f}%")
    else:
        st.info("ファンダメンタルデータが利用できません")

def render_forecast_accuracy_analysis(accuracy_df, forecast_df, ticker):
    """業績予想精度分析の詳細表示"""
    if not accuracy_df.empty:
        # 精度メトリクス
        avg_abs_error = accuracy_df['Error_Rate'].abs().mean()
        
        col_acc1, col_acc2, col_acc3 = st.columns(3)
        
        with col_acc1:
            if avg_abs_error < 5:
                precision_grade = "🎯 高精度"
                precision_color = "success"
            elif avg_abs_error < 15:
                precision_grade = "👍 標準的"
                precision_color = "info"
            else:
                precision_grade = "⚠️ 低精度"
                precision_color = "warning"
            
            st.metric("予想精度", precision_grade, f"平均誤差率: {avg_abs_error:.1f}%")
        
        with col_acc2:
            positive_errors = (accuracy_df['Error_Rate'] > 0).sum()
            total_forecasts = len(accuracy_df)
            upward_bias = (positive_errors / total_forecasts) * 100 if total_forecasts > 0 else 0
            
            if upward_bias > 60:
                bias_type = "楽観的"
            elif upward_bias < 40:
                bias_type = "保守的"
            else:
                bias_type = "バランス型"
            
            st.metric("予想傾向", bias_type, f"上振れ率: {upward_bias:.0f}%")
        
        with col_acc3:
            # 最新年度の精度
            latest_fy = accuracy_df['FY'].max()
            latest_accuracy = accuracy_df[accuracy_df['FY'] == latest_fy]['Error_Rate'].abs().mean()
            st.metric("最新年度精度", f"{latest_accuracy:.1f}%", f"FY{latest_fy}")

# --- ボラティリティ・リスク分析機能 ---
def calculate_volatility_metrics(data):
    """ボラティリティとリスク指標を計算"""
    try:
        # 日次リターンの計算
        if isinstance(data.columns, pd.MultiIndex):
            close_prices = data.iloc[:, data.columns.get_level_values(0) == 'Close'].iloc[:, 0]
        else:
            close_prices = data['Close']
        
        daily_returns = close_prices.pct_change().dropna()
        
        # ボラティリティ計算（年率換算）
        daily_volatility = daily_returns.std()
        annual_volatility = daily_volatility * np.sqrt(252)  # 年間営業日252日
        
        # 月次ボラティリティ
        monthly_volatility = daily_volatility * np.sqrt(22)  # 月間営業日22日
        
        # 四半期ボラティリティ
        quarterly_volatility = daily_volatility * np.sqrt(66)  # 四半期営業日66日
        
        # VaR計算（Value at Risk）
        var_95 = np.percentile(daily_returns, 5)  # 5%VaR（日次）
        var_99 = np.percentile(daily_returns, 1)  # 1%VaR（日次）
        
        # 取引高データ（流動性リスク）
        if isinstance(data.columns, pd.MultiIndex):
            volume_data = data.iloc[:, data.columns.get_level_values(0) == 'Volume'].iloc[:, 0]
        else:
            volume_data = data['Volume']
        
        avg_volume = volume_data.mean()
        volume_volatility = volume_data.std() / avg_volume  # 出来高の変動係数
        
        return {
            'daily_volatility': daily_volatility,
            'annual_volatility': annual_volatility,
            'monthly_volatility': monthly_volatility,
            'quarterly_volatility': quarterly_volatility,
            'var_95': var_95,
            'var_99': var_99,
            'avg_volume': avg_volume,
            'volume_volatility': volume_volatility,
            'daily_returns': daily_returns,
            'close_prices': close_prices
        }
    except Exception as e:
        st.error(f"ボラティリティ計算エラー: {str(e)}")
        return None

def predict_next_day_price(volatility_metrics, confidence_level=0.68):
    """次営業日の終値予測（正規分布仮定）"""
    try:
        current_price = volatility_metrics['close_prices'].iloc[-1]
        daily_vol = volatility_metrics['daily_volatility']
        avg_return = volatility_metrics['daily_returns'].mean()
        
        # 予測価格レンジ（正規分布仮定）
        expected_return = avg_return
        
        if confidence_level == 0.68:  # 1標準偏差
            upper_bound = current_price * (1 + expected_return + daily_vol)
            lower_bound = current_price * (1 + expected_return - daily_vol)
        elif confidence_level == 0.95:  # 2標準偏差
            upper_bound = current_price * (1 + expected_return + 2 * daily_vol)
            lower_bound = current_price * (1 + expected_return - 2 * daily_vol)
        else:  # 3標準偏差
            upper_bound = current_price * (1 + expected_return + 3 * daily_vol)
            lower_bound = current_price * (1 + expected_return - 3 * daily_vol)
        
        expected_price = current_price * (1 + expected_return)
        
        return {
            'current_price': current_price,
            'expected_price': expected_price,
            'upper_bound': upper_bound,
            'lower_bound': lower_bound,
            'confidence_level': confidence_level,
            'daily_volatility': daily_vol,
            'expected_return': expected_return
        }
    except Exception as e:
        st.error(f"価格予測エラー: {str(e)}")
        return None

def calculate_portfolio_risk_metrics(ticker1_data, ticker2_data, weight1=0.5, weight2=0.5):
    """ポートフォリオのリスク指標計算"""
    try:
        # 各銘柄のボラティリティ計算
        vol1_metrics = calculate_volatility_metrics(ticker1_data)
        vol2_metrics = calculate_volatility_metrics(ticker2_data)
        
        if not vol1_metrics or not vol2_metrics:
            return None
        
        # 相関係数計算
        returns1 = vol1_metrics['daily_returns']
        returns2 = vol2_metrics['daily_returns']
        
        # 共通期間での相関計算
        common_dates = returns1.index.intersection(returns2.index)
        correlation = returns1.loc[common_dates].corr(returns2.loc[common_dates])
        
        # ポートフォリオのボラティリティ
        vol1 = vol1_metrics['annual_volatility']
        vol2 = vol2_metrics['annual_volatility']
        
        portfolio_volatility = np.sqrt(
            (weight1 ** 2) * (vol1 ** 2) + 
            (weight2 ** 2) * (vol2 ** 2) + 
            2 * weight1 * weight2 * correlation * vol1 * vol2
        )
        
        # 分散効果の測定
        weighted_avg_vol = weight1 * vol1 + weight2 * vol2
        diversification_benefit = weighted_avg_vol - portfolio_volatility
        
        return {
            'portfolio_volatility': portfolio_volatility,
            'vol1': vol1,
            'vol2': vol2,
            'correlation': correlation,
            'diversification_benefit': diversification_benefit,
            'weighted_avg_vol': weighted_avg_vol
        }
    except Exception as e:
        st.error(f"ポートフォリオリスク計算エラー: {str(e)}")
        return None

def render_volatility_analysis(ticker, data):
    """ボラティリティ分析の表示"""
    vol_metrics = calculate_volatility_metrics(data)
    if not vol_metrics:
        return
    
    st.markdown("### 📊 ボラティリティ・リスク分析")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric(
            "年率ボラティリティ",
            f"{vol_metrics['annual_volatility']:.1%}",
            help="株価の年間変動率の標準偏差"
        )
    
    with col2:
        st.metric(
            "月次ボラティリティ",
            f"{vol_metrics['monthly_volatility']:.1%}",
            help="株価の月間変動率の標準偏差"
        )
    
    with col3:
        st.metric(
            "5%VaR（日次）",
            f"{vol_metrics['var_95']:.1%}",
            help="5%の確率で発生する最大損失"
        )
    
    with col4:
        st.metric(
            "平均出来高",
            f"{vol_metrics['avg_volume']:,.0f}株",
            help="流動性リスクの指標"
        )
    
    # 予測セクション
    st.markdown("### 🔮 次営業日価格予測")
    
    confidence_level = st.selectbox(
        "信頼区間を選択:",
        [("68%（1標準偏差）", 0.68), ("95%（2標準偏差）", 0.95), ("99.7%（3標準偏差）", 0.997)]
    )
    
    prediction = predict_next_day_price(vol_metrics, confidence_level[1])
    
    if prediction:
        col_pred1, col_pred2, col_pred3 = st.columns(3)
        
        with col_pred1:
            st.metric(
                "現在価格",
                f"¥{prediction['current_price']:,.0f}"
            )
        
        with col_pred2:
            change_pct = (prediction['expected_price'] - prediction['current_price']) / prediction['current_price']
            st.metric(
                "予想価格",
                f"¥{prediction['expected_price']:,.0f}",
                f"{change_pct:+.2%}"
            )
        
        with col_pred3:
            range_pct = (prediction['upper_bound'] - prediction['lower_bound']) / prediction['current_price']
            st.metric(
                f"予想レンジ（{confidence_level[0]}）",
                f"¥{prediction['lower_bound']:,.0f} - ¥{prediction['upper_bound']:,.0f}",
                f"±{range_pct/2:.1%}"
            )
        
        # リスク分析
        st.markdown("### ⚠️ リスク分析")
        
        col_risk1, col_risk2 = st.columns(2)
        
        with col_risk1:
            st.markdown("**投資額別リスク試算**")
            
            investment_amounts = [500000, 1000000, 1500000]  # 50万、100万、150万円
            
            for amount in investment_amounts:
                shares = amount / prediction['current_price']
                daily_var = shares * prediction['current_price'] * abs(vol_metrics['var_95'])
                monthly_var = daily_var * np.sqrt(22)
                
                st.write(f"**{amount/10000:.0f}万円投資時:**")
                st.write(f"- 日次5%VaR: ¥{daily_var:,.0f}")
                st.write(f"- 月次5%VaR: ¥{monthly_var:,.0f}")
                st.write("---")
        
        with col_risk2:
            st.markdown("**ボラティリティ解釈**")
            
            annual_vol = vol_metrics['annual_volatility']
            
            if annual_vol < 0.20:
                risk_level = "🟢 低リスク"
                risk_desc = "比較的安定した値動き"
            elif annual_vol < 0.35:
                risk_level = "🟡 中リスク"
                risk_desc = "標準的な値動き"
            else:
                risk_level = "🔴 高リスク"
                risk_desc = "大きな値動きが予想される"
            
            st.info(f"""
            **{risk_level}**
            
            年率ボラティリティ: {annual_vol:.1%}
            
            {risk_desc}
            
            **1標準偏差イベント（68%確率）:**
            年間で {annual_vol:.1%} の変動幅
            
            **2標準偏差イベント（95%確率）:**
            年間で {annual_vol*2:.1%} の変動幅
            """)

# --- 市場リスクアラート機能 ---
def get_market_indices_data():
    """主要市場指数のデータを取得"""
    try:
        indices = {
            '^N225': '日経平均',
            '1305.T': 'TOPIX',
            '6758.T': 'ソニーG',
            '7203.T': 'トヨタ',
            '6861.T': 'キーエンス',
            '8306.T': '三菱UFJ',
            '9983.T': 'ファストリ'
        }
        
        market_data = {}
        for ticker, name in indices.items():
            try:
                data = yf.download(ticker, period='5d', progress=False, auto_adjust=True)
                if not data.empty:
                    # MultiIndexの場合の処理
                    if isinstance(data.columns, pd.MultiIndex):
                        close_data = data.iloc[:, data.columns.get_level_values(0) == 'Close'].iloc[:, 0]
                    else:
                        close_data = data['Close']
                    
                    latest_price = float(close_data.iloc[-1])
                    prev_price = float(close_data.iloc[-2]) if len(close_data) > 1 else latest_price
                    
                    market_data[ticker] = {
                        'name': name,
                        'data': data,
                        'latest_price': latest_price,
                        'prev_price': prev_price,
                    }
            except:
                continue
        
        return market_data
    except Exception as e:
        st.error(f"市場データ取得エラー: {str(e)}")
        return {}

def calculate_market_risk_level(market_data):
    """市場リスクレベルの計算"""
    try:
        risk_signals = []
        total_weight = 0
        weighted_decline = 0
        
        # 各指数の重み付け
        weights = {
            '^N225': 0.3,    # 日経平均 30%
            '1305.T': 0.25,  # TOPIX 25%
            '6758.T': 0.1,   # ソニー 10%
            '7203.T': 0.1,   # トヨタ 10%
            '6861.T': 0.1,   # キーエンス 10%
            '8306.T': 0.075, # 三菱UFJ 7.5%
            '9983.T': 0.075  # ファストリ 7.5%
        }
        
        for ticker, info in market_data.items():
            if ticker in weights:
                change_pct = ((info['latest_price'] - info['prev_price']) / info['prev_price']) * 100
                weight = weights[ticker]
                
                total_weight += weight
                weighted_decline += change_pct * weight
                
                # 個別銘柄の下落率チェック
                if change_pct < -3:
                    risk_signals.append(f"{info['name']}: {change_pct:.1f}% 下落")
                elif change_pct < -5:
                    risk_signals.append(f"⚠️ {info['name']}: {change_pct:.1f}% 大幅下落")
        
        # 加重平均下落率
        avg_decline = weighted_decline / total_weight if total_weight > 0 else 0
        
        # リスクレベル判定
        if avg_decline < -3:
            risk_level = "🔴 高リスク"
            risk_description = "市場全体の大幅下落。スタンダード市場銘柄は大きく下落する可能性があります。"
            action_recommended = "利確して現金ポジションへの退避を検討してください。"
        elif avg_decline < -1.5:
            risk_level = "🟡 中リスク"
            risk_description = "市場に不安定な動きが見られます。"
            action_recommended = "ポジションサイズの縮小を検討してください。"
        elif avg_decline < -0.5:
            risk_level = "🟠 軽微リスク"
            risk_description = "市場に若干の下落圧力があります。"
            action_recommended = "様子見で良いですが、損切りラインの確認をしてください。"
        else:
            risk_level = "🟢 低リスク"
            risk_description = "市場は安定しています。"
            action_recommended = "通常の投資戦略で問題ありません。"
        
        return {
            'risk_level': risk_level,
            'avg_decline': avg_decline,
            'risk_description': risk_description,
            'action_recommended': action_recommended,
            'risk_signals': risk_signals,
            'total_signals': len(risk_signals)
        }
        
    except Exception as e:
        return {
            'risk_level': "❓ 不明",
            'avg_decline': 0,
            'risk_description': f"リスク計算エラー: {str(e)}",
            'action_recommended': "手動で市場状況を確認してください。",
            'risk_signals': [],
            'total_signals': 0
        }

def calculate_portfolio_survival_probability(market_decline, portfolio_tickers):
    """ポートフォリオの生存確率計算"""
    try:
        # スタンダード市場のベータ値（大型株に対する感応度）
        # 一般的にスタンダード市場はベータが1.2-1.5程度
        beta_multiplier = 1.3
        
        expected_portfolio_decline = market_decline * beta_multiplier
        
        # 強制終了ライン（-10%）に対する余裕度
        margin_to_liquidation = -10 - expected_portfolio_decline
        
        if margin_to_liquidation <= 0:
            survival_prob = 0  # 強制終了の可能性高
            warning_level = "🚨 緊急"
        elif margin_to_liquidation <= 2:
            survival_prob = 30  # 低い生存確率
            warning_level = "🔴 危険"
        elif margin_to_liquidation <= 5:
            survival_prob = 70  # 中程度の生存確率
            warning_level = "🟡 注意"
        else:
            survival_prob = 95  # 高い生存確率
            warning_level = "🟢 安全"
        
        return {
            'survival_probability': survival_prob,
            'expected_decline': expected_portfolio_decline,
            'margin_to_liquidation': margin_to_liquidation,
            'warning_level': warning_level
        }
        
    except Exception as e:
        return {
            'survival_probability': 50,
            'expected_decline': 0,
            'margin_to_liquidation': 0,
            'warning_level': "❓ 不明"
        }

def analyze_individual_ticker_risk(ticker, market_decline):
    """個別銘柄のリスク分析"""
    try:
        # 銘柄データ取得
        data = yf.download(ticker, period='1mo', progress=False, auto_adjust=True)
        if data.empty:
            return None
        
        # ボラティリティ計算
        if isinstance(data.columns, pd.MultiIndex):
            close_prices = data.iloc[:, data.columns.get_level_values(0) == 'Close'].iloc[:, 0]
        else:
            close_prices = data['Close']
        
        daily_returns = close_prices.pct_change().dropna()
        current_price = close_prices.iloc[-1]
        
        # ベータ値推定（簡易版）
        if len(daily_returns) > 10:
            volatility = daily_returns.std()
            # スタンダード市場のベータ値は通常1.2-1.5
            estimated_beta = 1.3 if volatility > 0.03 else 1.1
        else:
            estimated_beta = 1.3
        
        # 予想下落率
        expected_decline = market_decline * estimated_beta
        expected_price = current_price * (1 + expected_decline / 100)
        
        # 強制終了ラインまでの余裕
        liquidation_threshold = current_price * 0.9  # -10%
        margin_to_liquidation = ((expected_price - liquidation_threshold) / liquidation_threshold) * 100
        
        # リスクレベル判定
        if margin_to_liquidation <= -5:
            risk_status = "🚨 即座に売却推奨"
            risk_color = "error"
        elif margin_to_liquidation <= 0:
            risk_status = "🔴 高リスク"
            risk_color = "error"
        elif margin_to_liquidation <= 5:
            risk_status = "🟡 注意"
            risk_color = "warning"
        else:
            risk_status = "🟢 相対的に安全"
            risk_color = "success"
        
        return {
            'ticker': ticker,
            'current_price': current_price,
            'expected_price': expected_price,
            'expected_decline': expected_decline,
            'margin_to_liquidation': margin_to_liquidation,
            'risk_status': risk_status,
            'risk_color': risk_color,
            'estimated_beta': estimated_beta
        }
        
    except Exception as e:
        return None

def render_portfolio_specific_risk_analysis():
    """保有銘柄固有のリスク分析"""
    st.markdown("### 🎯 保有銘柄リスク分析")
    
    target_tickers = ['6357.T', '4816.T', '2991.T', '7564.T', '7711.T', '6405.T', 
                     '2428.T', '6231.T', '6855.T', '4832.T', '4767.T']
    
    # 市場データ取得
    market_data = get_market_indices_data()
    if not market_data:
        st.error("市場データが取得できません")
        return
    
    risk_info = calculate_market_risk_level(market_data)
    market_decline = risk_info['avg_decline']
    
    # 保有銘柄を選択
    selected_tickers = st.multiselect(
        "リスク分析したい保有銘柄を選択:",
        target_tickers,
        default=target_tickers[:3],  # デフォルトで最初の3銘柄
        format_func=lambda x: f"{x.replace('.T', '')} - {TICKER_NAMES.get(x, 'Unknown')}"
    )
    
    if selected_tickers:
        st.markdown(f"**市場下落率:** {market_decline:.1f}% を基準にした分析")
        
        risk_analysis_results = []
        
        for ticker in selected_tickers:
            with st.spinner(f"📊 {ticker} を分析中..."):
                risk_result = analyze_individual_ticker_risk(ticker, market_decline)
                if risk_result:
                    risk_analysis_results.append(risk_result)
        
        if risk_analysis_results:
            # 結果の表示
            col1, col2 = st.columns([2, 1])
            
            with col1:
                # 詳細テーブル
                risk_df_data = []
                for result in risk_analysis_results:
                    risk_df_data.append({
                        '銘柄': result['ticker'].replace('.T', ''),
                        '企業名': TICKER_NAMES.get(result['ticker'], 'Unknown'),
                        '現在価格': f"¥{result['current_price']:,.0f}",
                        '予想価格': f"¥{result['expected_price']:,.0f}",
                        '予想下落率': f"{result['expected_decline']:+.1f}%",
                        '強制終了余裕': f"{result['margin_to_liquidation']:+.1f}%",
                        'リスク評価': result['risk_status']
                    })
                
                risk_df = pd.DataFrame(risk_df_data)
                st.dataframe(risk_df, use_container_width=True)
            
            with col2:
                # リスクサマリー
                high_risk_count = sum(1 for r in risk_analysis_results if '🚨' in r['risk_status'] or '🔴' in r['risk_status'])
                medium_risk_count = sum(1 for r in risk_analysis_results if '🟡' in r['risk_status'])
                low_risk_count = len(risk_analysis_results) - high_risk_count - medium_risk_count
                
                st.metric("🚨 高リスク銘柄", f"{high_risk_count}銘柄")
                st.metric("🟡 注意銘柄", f"{medium_risk_count}銘柄")
                st.metric("🟢 相対的安全", f"{low_risk_count}銘柄")
            
            # 推奨アクション
            if high_risk_count > 0:
                st.error(f"""
                🚨 **緊急推奨アクション**
                
                {high_risk_count}銘柄で高リスクが検出されました。
                
                **即座に実行を推奨:**
                1. 🏃 高リスク銘柄の即座売却
                2. 💰 利確可能銘柄の利確実行
                3. 🔒 新規ポジション取得停止
                4. 📊 市場回復まで現金ポジション維持
                """)
            elif medium_risk_count > 0:
                st.warning(f"""
                ⚠️ **注意が必要**
                
                {medium_risk_count}銘柄で注意レベルのリスクがあります。
                
                **推奨アクション:**
                1. 📉 ポジションサイズ縮小検討
                2. 🎯 損切りライン再設定
                3. 👀 市場動向の継続監視
                """)
            else:
                st.success("""
                🟢 **現在は相対的に安全**
                
                選択された銘柄は現在の市場状況では比較的安全です。
                
                **継続推奨:**
                1. 📊 定期的なリスクチェック
                2. 🎯 損切りラインの維持
                3. 📈 市場動向の監視継続
                """)

def render_market_risk_alert():
    """市場リスクアラートの表示"""
    st.markdown("### 🚨 市場リスクアラート")
    
    with st.spinner("📊 市場データを分析中..."):
        market_data = get_market_indices_data()
    
    if not market_data:
        st.error("❌ 市場データを取得できませんでした")
        return
    
    # リスクレベル計算
    risk_info = calculate_market_risk_level(market_data)
    
    # アラート表示
    with st.container(border=True):
        col_risk1, col_risk2, col_risk3 = st.columns(3)
        
        with col_risk1:
            st.metric(
                "現在のリスクレベル",
                risk_info['risk_level'],
                f"市場平均: {risk_info['avg_decline']:+.1f}%"
            )
        
        with col_risk2:
            st.metric(
                "アラート件数",
                f"{risk_info['total_signals']}件",
                "大型株下落検出"
            )
        
        with col_risk3:
            # ポートフォリオ生存確率（例として最初の2銘柄）
            target_tickers = ['6357.T', '4816.T']  # 例
            survival_info = calculate_portfolio_survival_probability(
                risk_info['avg_decline'], target_tickers
            )
            
            st.metric(
                "ポートフォリオ生存確率",
                f"{survival_info['survival_probability']}%",
                survival_info['warning_level']
            )
    
    # 詳細情報
    with st.expander("📋 詳細な市場分析"):
        st.markdown(f"**状況説明:** {risk_info['risk_description']}")
        st.markdown(f"**推奨アクション:** {risk_info['action_recommended']}")
        
        if risk_info['risk_signals']:
            st.markdown("**個別アラート:**")
            for signal in risk_info['risk_signals']:
                st.write(f"- {signal}")
        
        # 市場データテーブル
        market_summary = []
        for ticker, info in market_data.items():
            try:
                # Seriesの場合は値を取得
                latest_price = float(info['latest_price'])
                prev_price = float(info['prev_price'])
                change_pct = ((latest_price - prev_price) / prev_price) * 100
                
                market_summary.append({
                    '指数/銘柄': info['name'],
                    'ティッカー': ticker,
                    '最新価格': f"{latest_price:,.0f}",
                    '前日比(%)': f"{change_pct:+.2f}",
                    'ステータス': '🔴 下落' if change_pct < -1 else '🟡 軟調' if change_pct < 0 else '🟢 上昇'
                })
            except Exception as e:
                # エラーが発生した場合はスキップ
                continue
        
        if market_summary:
            market_df = pd.DataFrame(market_summary)
            
            # 前日比の色付け用スタイル関数
            def color_change_pct_market(val):
                """前日比の値に応じて色を設定（正は赤、負は青）"""
                try:
                    # 文字列から数値を抽出（+や%を除去）
                    numeric_val = float(val.replace('+', '').replace('%', ''))
                    if numeric_val > 0:
                        return 'background-color: #ffebee; color: #d32f2f; font-weight: bold'  # 薄い赤背景、濃い赤文字
                    elif numeric_val < 0:
                        return 'background-color: #e3f2fd; color: #1976d2; font-weight: bold'  # 薄い青背景、濃い青文字
                    else:
                        return 'background-color: #f5f5f5; color: #666666'  # グレー
                except:
                    return 'color: black'
            
            # スタイルを適用
            styled_df = market_df.style.apply(
                lambda x: [''] * len(x) if x.name != '前日比(%)' 
                else [color_change_pct_market(val) for val in x], 
                axis=0
            )
            
            st.dataframe(styled_df, use_container_width=True)
    
    # 保有銘柄固有のリスク分析
    st.markdown("---")
    render_portfolio_specific_risk_analysis()
    
    # 緊急アラート
    if risk_info['avg_decline'] < -3:
        st.error("""
        🚨 **緊急アラート: 市場大幅下落**
        
        大型株・指数が大幅下落しています。スタンダード市場銘柄は連動して下落する可能性が高いです。
        
        **推奨行動:**
        1. 💰 即座に利確を検討
        2. 🏃 現金ポジションへの退避
        3. 📉 新規ポジション取得の延期
        4. 🔍 市場回復まで様子見
        """)
    elif risk_info['avg_decline'] < -1.5:
        st.warning("""
        ⚠️ **注意: 市場不安定**
        
        市場に不安定な動きが見られます。慎重な対応が必要です。
        
        **推奨行動:**
        1. 📉 ポジションサイズの縮小
        2. 🎯 損切りラインの再確認
        3. 👀 市場動向の継続監視
        """)

# --- ポートフォリオ戦略室 ---
def render_portfolio_strategy_page():
    """ポートフォリオ戦略室のメインページ"""
    st.title("📊 ポートフォリオ戦略室")
    st.markdown("---")
    
    # ゲームルールの説明
    with st.container(border=True):
        st.subheader("🎮 投資ゲームルール")
        col_rule1, col_rule2 = st.columns(2)
        
        with col_rule1:
            st.markdown("""
            **基本設定:**
            - 💰 初期資金: 3,000,000円
            - 📈 ポートフォリオ: 2銘柄のみ
            - 🏢 対象: 東証スタンダード市場
            - 📊 条件: 時価総額50億円以上、上場1年以上
            """)
        
        with col_rule2:
            st.markdown("""
            **取引ルール:**
            - ⏰ 取引時間: 9:00始値 または 15:00終値
            - 🔒 最低保有期間: 3日間
            - 🚨 強制終了: 累積損失30万円
            - 📅 投資期間: 過去データでバックテスト
            """)
    
    # タブ分けによる機能整理
    tab1, tab2, tab3, tab4 = st.tabs(["🚨 市場リスクアラート", "🔍 銘柄分析", "📊 ボラティリティ分析", "🎯 ポートフォリオ最適化"])

    with tab1:
        render_market_risk_alert()
    
    with tab2:
        render_ticker_analysis_tab()
    
    with tab3:
        render_volatility_analysis_tab()
    
    with tab4:
        render_portfolio_optimization_tab()

def render_ticker_analysis_tab():
    """銘柄分析タブ"""
    target_tickers = ['6357.T', '4816.T', '2991.T', '7564.T', '7711.T', '6405.T', 
                     '2428.T', '6231.T', '6855.T', '4832.T', '4767.T']
    
    # テスト用: 1つの銘柄でデータ取得テスト
    st.subheader("🔍 データ取得テスト")
    test_ticker = target_tickers[0]
    
    with st.expander("データ取得テスト結果"):
        try:
            test_data = yf.download(test_ticker, period='1mo', progress=False, auto_adjust=True)
            if not test_data.empty:
                st.success(f"✅ {test_ticker}: データ取得成功 ({len(test_data)}日分)")
                
                # カラム構造をチェック
                if isinstance(test_data.columns, pd.MultiIndex):
                    st.write("カラム構造: MultiIndex")
                    st.write(f"レベル0: {list(test_data.columns.get_level_values(0))}")
                    st.write(f"レベル1: {list(test_data.columns.get_level_values(1))}")
                else:
                    st.write(f"カラム: {list(test_data.columns)}")
                    
                st.write(f"期間: {test_data.index[0].strftime('%Y-%m-%d')} ～ {test_data.index[-1].strftime('%Y-%m-%d')}")
            else:
                st.error(f"❌ {test_ticker}: データが空")
        except Exception as e:
            st.error(f"❌ {test_ticker}: エラー - {str(e)}")
    
    # 銘柄の事前分析
    st.subheader("📋 銘柄分析")
    
    with st.spinner("📊 銘柄の事前条件を確認中..."):
        eligible_tickers = analyze_ticker_eligibility(target_tickers)
    
    if eligible_tickers:
        st.success(f"✅ 条件を満たす銘柄: {len(eligible_tickers)}銘柄")
        
        # 組み合わせ分析
        st.subheader("🔍 ポートフォリオ組み合わせ分析")
        combinations_df = analyze_portfolio_combinations(eligible_tickers)
        
        if not combinations_df.empty:
            # ソート機能付きテーブル表示
            sort_option = st.selectbox(
                "ソート基準:",
                ["シャープレシオ(降順)", "リスク(昇順)", "相関(昇順)", "期待リターン(降順)"]
            )
            
            sorted_df = sort_combinations(combinations_df, sort_option)
            
            st.dataframe(
                sorted_df.style.format({
                    '期待リターン(年率)': '{:.2%}',
                    'リスク(年率)': '{:.2%}',
                    '相関係数': '{:.3f}',
                    'シャープレシオ': '{:.3f}'
                }),
                use_container_width=True
            )
        else:
            st.error("❌ 組み合わせ分析でエラーが発生しました")
    else:
        st.error("❌ 条件を満たす銘柄が見つかりませんでした")

def render_volatility_analysis_tab():
    """ボラティリティ分析タブ"""
    st.subheader("📊 個別銘柄ボラティリティ分析")
    
    target_tickers = ['6357.T', '4816.T', '2991.T', '7564.T', '7711.T', '6405.T', 
                     '2428.T', '6231.T', '6855.T', '4832.T', '4767.T']
    
    # 銘柄選択
    selected_ticker = st.selectbox(
        "分析する銘柄を選択:",
        target_tickers,
        format_func=lambda x: f"{x.replace('.T', '')} - {TICKER_NAMES.get(x, 'Unknown')}"
    )
    
    # 分析期間選択
    period_option = st.selectbox(
        "分析期間:",
        [("1年", "1y"), ("6ヶ月", "6mo"), ("3ヶ月", "3mo"), ("1ヶ月", "1mo")]
    )
    
    if st.button("📊 ボラティリティ分析実行", type="primary"):
        with st.spinner(f"📊 {selected_ticker}のボラティリティを分析中..."):
            try:
                # データ取得
                data = yf.download(selected_ticker, period=period_option[1], progress=False, auto_adjust=True)
                
                if not data.empty:
                    # ボラティリティ分析表示
                    render_volatility_analysis(selected_ticker, data)
                    
                    # 価格チャート
                    st.markdown("### 📈 価格チャート")
                    
                    if isinstance(data.columns, pd.MultiIndex):
                        close_prices = data.iloc[:, data.columns.get_level_values(0) == 'Close'].iloc[:, 0]
                    else:
                        close_prices = data['Close']
                    
                    fig = go.Figure()
                    fig.add_trace(go.Scatter(
                        x=close_prices.index,
                        y=close_prices.values,
                        mode='lines',
                        name='終値',
                        line=dict(color='blue', width=2)
                    ))
                    
                    fig.update_layout(
                        title=f"{TICKER_NAMES.get(selected_ticker, selected_ticker)} 価格推移",
                        xaxis_title="日付",
                        yaxis_title="価格 (円)",
                        height=400
                    )
                    
                    st.plotly_chart(fig, use_container_width=True)
                    
                else:
                    st.error(f"❌ {selected_ticker}のデータを取得できませんでした")
                    
            except Exception as e:
                st.error(f"❌ 分析エラー: {str(e)}")

def render_portfolio_optimization_tab():
    """ポートフォリオ最適化タブ"""
    st.subheader("🎯 2銘柄ポートフォリオ最適化")
    
    target_tickers = ['6357.T', '4816.T', '2991.T', '7564.T', '7711.T', '6405.T', 
                     '2428.T', '6231.T', '6855.T', '4832.T', '4767.T']
    
    col1, col2 = st.columns(2)
    
    with col1:
        ticker1 = st.selectbox(
            "銘柄1を選択:",
            target_tickers,
            format_func=lambda x: f"{x.replace('.T', '')} - {TICKER_NAMES.get(x, 'Unknown')}"
        )
    
    with col2:
        ticker2 = st.selectbox(
            "銘柄2を選択:",
            [t for t in target_tickers if t != ticker1],
            format_func=lambda x: f"{x.replace('.T', '')} - {TICKER_NAMES.get(x, 'Unknown')}"
        )
    
    # 投資配分
    col_weight1, col_weight2 = st.columns(2)
    
    with col_weight1:
        weight1 = st.slider(f"{ticker1.replace('.T', '')}の配分", 0, 100, 50, 5)
    
    with col_weight2:
        weight2 = 100 - weight1
        st.metric(f"{ticker2.replace('.T', '')}の配分", f"{weight2}%")
    
    if st.button("🔍 ポートフォリオ分析実行", type="primary"):
        with st.spinner("📊 ポートフォリオリスクを分析中..."):
            try:
                # 両銘柄のデータ取得
                data1 = yf.download(ticker1, period='1y', progress=False, auto_adjust=True)
                data2 = yf.download(ticker2, period='1y', progress=False, auto_adjust=True)
                
                if not data1.empty and not data2.empty:
                    # ポートフォリオリスク分析
                    portfolio_metrics = calculate_portfolio_risk_metrics(
                        data1, data2, weight1/100, weight2/100
                    )
                    
                    if portfolio_metrics:
                        st.markdown("### 📊 ポートフォリオリスク分析結果")
                        
                        col_port1, col_port2, col_port3 = st.columns(3)
                        
                        with col_port1:
                            st.metric(
                                "ポートフォリオボラティリティ",
                                f"{portfolio_metrics['portfolio_volatility']:.1%}",
                                help="2銘柄組み合わせの年率ボラティリティ"
                            )
                        
                        with col_port2:
                            st.metric(
                                "相関係数",
                                f"{portfolio_metrics['correlation']:.3f}",
                                help="2銘柄間の価格変動の相関"
                            )
                        
                        with col_port3:
                            diversification_pct = (portfolio_metrics['diversification_benefit'] / 
                                                 portfolio_metrics['weighted_avg_vol']) * 100
                            st.metric(
                                "分散効果",
                                f"{diversification_pct:.1f}%",
                                help="分散投資によるリスク軽減効果"
                            )
                        
                        # 分散効果の可視化
                        st.markdown("### 📈 分散効果の比較")
                        
                        comparison_data = {
                            '指標': ['銘柄1単独', '銘柄2単独', '加重平均', 'ポートフォリオ'],
                            'ボラティリティ': [
                                portfolio_metrics['vol1'],
                                portfolio_metrics['vol2'],
                                portfolio_metrics['weighted_avg_vol'],
                                portfolio_metrics['portfolio_volatility']
                            ]
                        }
                        
                        comparison_df = pd.DataFrame(comparison_data)
                        
                        fig = go.Figure()
                        colors = ['lightcoral', 'lightblue', 'orange', 'green']
                        
                        for i, row in comparison_df.iterrows():
                            fig.add_trace(go.Bar(
                                x=[row['指標']],
                                y=[row['ボラティリティ']],
                                name=row['指標'],
                                marker_color=colors[i],
                                showlegend=False
                            ))
                        
                        fig.update_layout(
                            title="ボラティリティ比較",
                            yaxis_title="年率ボラティリティ",
                            height=400
                        )
                        
                        st.plotly_chart(fig, use_container_width=True)
                        
                        # リスク分析のまとめ
                        st.markdown("### 💡 ポートフォリオ評価")
                        
                        if portfolio_metrics['correlation'] < 0.3:
                            correlation_grade = "🟢 優秀な分散効果"
                        elif portfolio_metrics['correlation'] < 0.7:
                            correlation_grade = "🟡 適度な分散効果"
                        else:
                            correlation_grade = "🔴 分散効果が限定的"
                        
                        st.info(f"""
                        **相関分析:** {correlation_grade}
                        
                        **分散効果:** {diversification_pct:.1f}%のリスク削減
                        
                        **推奨度:**
                        - 相関係数: {portfolio_metrics['correlation']:.3f} {'(低相関で良好)' if portfolio_metrics['correlation'] < 0.5 else '(高相関で注意)'}
                        - ポートフォリオボラティリティ: {portfolio_metrics['portfolio_volatility']:.1%}
                        """)
                        
                        # シミュレーション実行部分
                        st.markdown("---")
                        st.subheader("🎯 バックテストシミュレーション")
                        
                        selected_tickers_clean = [ticker1.replace('.T', ''), ticker2.replace('.T', '')]
                        render_simulation_interface(selected_tickers_clean)
                        
                else:
                    st.error("❌ データの取得に失敗しました")
                    
            except Exception as e:
                st.error(f"❌ 分析エラー: {str(e)}")

def render_simulation_interface(selected_tickers):
    """シミュレーションインターフェース（修正版）"""
    if len(selected_tickers) != 2:
        st.warning("⚠️ 2銘柄を選択してください")
        return
    
    st.markdown("### ⚙️ シミュレーション設定")
    
    col_sim1, col_sim2 = st.columns(2)
    
    with col_sim1:
        # 投資配分
        allocation_a = st.slider(
            f"{selected_tickers[0]}の配分(%)",
            min_value=10, max_value=90, value=50, step=5
        )
        allocation_b = 100 - allocation_a
        st.metric(f"{selected_tickers[1]}の配分", f"{allocation_b}%")
        
        # 取引タイミング
        trading_time = st.selectbox(
            "取引タイミング:",
            ["9:00 始値", "15:00 終値"]
        )
    
    with col_sim2:
        # シミュレーション期間
        start_date = st.date_input(
            "開始日:",
            value=datetime.now() - timedelta(days=365),
            max_value=datetime.now() - timedelta(days=1)
        )
        
        end_date = st.date_input(
            "終了日:",
            value=datetime.now() - timedelta(days=1),
            max_value=datetime.now() - timedelta(days=1)
        )
    
    # シミュレーション実行
    if st.button("🚀 シミュレーション実行", type="primary", use_container_width=True):
        with st.spinner("📊 バックテストを実行中..."):
            results = run_portfolio_simulation(
                [f"{selected_tickers[0]}.T", f"{selected_tickers[1]}.T"],
                [allocation_a/100, allocation_b/100],
                start_date,
                end_date,
                trading_time == "9:00 始値"
            )
            
            if results:
                display_simulation_results(results, selected_tickers)

def analyze_ticker_eligibility(tickers):
    """銘柄の参加条件をチェック"""
    eligible_tickers = []
    eligibility_data = []
    
    # 各銘柄の実際の上場年（調査済み）
    listing_years = {
        '6357.T': 2000,  # 三精テクノロジーズ
        '4816.T': 1998,  # 東映アニメーション
        '2991.T': 2017,  # ランドネット
        '7564.T': 2000,  # ワークマン
        '7711.T': 1961,  # 助川電気工業
        '6405.T': 1961,  # 鈴茂器工
        '2428.T': 2000,  # ウェルネット
        '6231.T': 1997,  # 木村工機
        '6855.T': 1961,  # 日本電子材料
        '4832.T': 1989,  # JFEシステムズ
        '4767.T': 1998   # テー・オー・ダブリュー
    }
    
    current_year = datetime.now().year
    
    for ticker in tickers:
        try:
            yf_ticker = yf.Ticker(ticker)
            info = yf_ticker.info
            
            # 時価総額チェック (50億円以上)
            market_cap = info.get('marketCap', 0)
            market_cap_ok = market_cap >= 5_000_000_000  # 50億円
            
            # 上場期間チェック (1年以上) - 実際の上場年を使用
            listing_year = listing_years.get(ticker, current_year)
            years_listed = current_year - listing_year
            listing_ok = years_listed >= 1
            
            # 東証スタンダード市場チェック（.Tで判断）
            market_ok = ticker.endswith('.T')
            
            is_eligible = market_cap_ok and listing_ok and market_ok
            
            if is_eligible:
                eligible_tickers.append(ticker)
            
            eligibility_data.append({
                '銘柄コード': ticker,
                '企業名': get_japanese_company_name(ticker, info),
                '時価総額(億円)': f"{market_cap/1e8:.0f}" if market_cap > 0 else "N/A",
                '上場年': f"{listing_year}年" if listing_year < current_year else "不明",
                '上場期間': f"{years_listed}年",
                '時価総額OK': "✅" if market_cap_ok else "❌",
                '上場期間OK': "✅" if listing_ok else "❌",
                '市場OK': "✅" if market_ok else "❌",
                '参加可能': "✅" if is_eligible else "❌"
            })
            
        except Exception as e:
            st.warning(f"⚠️ {ticker} の情報取得エラー: {str(e)}")
            eligibility_data.append({
                '銘柄コード': ticker,
                '企業名': 'エラー',
                '時価総額(億円)': 'N/A',
                '上場年': 'N/A',
                '上場期間': 'N/A',
                '時価総額OK': "❌",
                '上場期間OK': "❌", 
                '市場OK': "❌",
                '参加可能': "❌"
            })
    
    # 結果表示
    eligibility_df = pd.DataFrame(eligibility_data)
    st.dataframe(eligibility_df, use_container_width=True)
    
    st.info(f"✅ 参加可能銘柄: {len(eligible_tickers)}個 / {len(tickers)}個")
    
    if len(eligible_tickers) > 0:
        st.success(f"参加可能銘柄: {', '.join([t.replace('.T', '') for t in eligible_tickers])}")
    else:
        st.error("❌ 参加可能な銘柄が見つかりませんでした。条件を確認してください。")
    
    return eligible_tickers

def analyze_portfolio_combinations(eligible_tickers):
    """全ポートフォリオ組み合わせの分析"""
    if len(eligible_tickers) < 2:
        st.warning("⚠️ 分析に必要な最低2銘柄が不足しています")
        return pd.DataFrame()
    
    combinations = list(itertools.combinations(eligible_tickers, 2))
    portfolio_data = []
    failed_combinations = []
    
    # プログレスバーを表示
    progress_bar = st.progress(0)
    total_combinations = len(combinations)
    
    st.write(f"📊 {total_combinations}組み合わせの分析を開始...")
    
    # まず1つの組み合わせで詳細テスト
    if combinations:
        test_ticker1, test_ticker2 = combinations[0]
        st.write(f"🔍 詳細テスト: {test_ticker1} × {test_ticker2}")
        
        with st.expander("詳細テスト結果"):
            try:
                # データ取得テスト
                st.write("1. データ取得中...")
                data1 = yf.download(test_ticker1, period='1y', progress=False, auto_adjust=True)
                data2 = yf.download(test_ticker2, period='1y', progress=False, auto_adjust=True)
                
                st.write(f"   {test_ticker1}: {len(data1)}行, カラム: {list(data1.columns)}")
                st.write(f"   {test_ticker2}: {len(data2)}行, カラム: {list(data2.columns)}")
                
                if not data1.empty and not data2.empty:
                    st.write("2. リターン計算中...")
                    
                    # MultiIndexの場合の処理
                    if isinstance(data1.columns, pd.MultiIndex):
                        # MultiIndexから単一のカラムを取得
                        close1 = data1.iloc[:, data1.columns.get_level_values(0) == 'Close'].iloc[:, 0]
                        close2 = data2.iloc[:, data2.columns.get_level_values(0) == 'Close'].iloc[:, 0]
                    else:
                        close1 = data1['Close']
                        close2 = data2['Close']
                    
                    returns1 = close1.pct_change().dropna()
                    returns2 = close2.pct_change().dropna()
                    
                    st.write(f"   {test_ticker1} リターン: {len(returns1)}個")
                    st.write(f"   {test_ticker2} リターン: {len(returns2)}個")
                    
                    # 共通日付
                    common_dates = returns1.index.intersection(returns2.index)
                    st.write(f"   共通日付: {len(common_dates)}個")
                    
                    if len(common_dates) >= 50:
                        returns1_common = returns1[common_dates]
                        returns2_common = returns2[common_dates]
                        
                        # 統計計算
                        portfolio_returns = 0.5 * returns1_common + 0.5 * returns2_common
                        expected_return = portfolio_returns.mean() * 252
                        portfolio_risk = portfolio_returns.std() * np.sqrt(252)
                        correlation = returns1_common.corr(returns2_common)
                        
                        st.write("3. 計算結果:")
                        st.write(f"   期待リターン: {expected_return:.4f}")
                        st.write(f"   リスク: {portfolio_risk:.4f}")
                        st.write(f"   相関: {correlation:.4f}")
                        
                        if not (pd.isna(expected_return) or pd.isna(portfolio_risk) or pd.isna(correlation)):
                            st.success("✅ テスト組み合わせは正常に計算できました")
                        else:
                            st.error("❌ NaN値が発生しました")
                    else:
                        st.error(f"❌ 共通日付が不足: {len(common_dates)}日")
                else:
                    st.error("❌ データ取得に失敗")
                    
            except Exception as e:
                st.error(f"❌ テストエラー: {str(e)}")
    
    for idx, (ticker1, ticker2) in enumerate(combinations):
        try:
            # プログレス更新
            progress_bar.progress((idx + 1) / total_combinations)
            
            # 過去1年のデータ取得
            data1 = yf.download(ticker1, period='1y', progress=False, auto_adjust=True)
            data2 = yf.download(ticker2, period='1y', progress=False, auto_adjust=True)
            
            # データ取得チェック
            if data1.empty:
                failed_combinations.append(f"{ticker1}: データが空")
                continue
                
            if data2.empty:
                failed_combinations.append(f"{ticker2}: データが空")
                continue
            
            # MultiIndexの場合の処理
            try:
                if isinstance(data1.columns, pd.MultiIndex):
                    # MultiIndexから'Close'カラムを取得
                    close1 = data1.iloc[:, data1.columns.get_level_values(0) == 'Close'].iloc[:, 0]
                    close2 = data2.iloc[:, data2.columns.get_level_values(0) == 'Close'].iloc[:, 0]
                else:
                    close1 = data1['Close']
                    close2 = data2['Close']
            except Exception as e:
                failed_combinations.append(f"{ticker1}×{ticker2}: Closeカラム取得エラー - {str(e)}")
                continue
                
            # 日次リターン計算
            returns1 = close1.pct_change().dropna()
            returns2 = close2.pct_change().dropna()
            
            # データ数チェック
            if len(returns1) == 0:
                failed_combinations.append(f"{ticker1}: リターンデータなし")
                continue
                
            if len(returns2) == 0:
                failed_combinations.append(f"{ticker2}: リターンデータなし")
                continue
            
            # 共通日付のみ
            common_dates = returns1.index.intersection(returns2.index)
            if len(common_dates) < 50:  # 最低50営業日
                failed_combinations.append(f"{ticker1}×{ticker2}: 共通データ不足 ({len(common_dates)}日)")
                continue
                
            returns1_common = returns1[common_dates]
            returns2_common = returns2[common_dates]
            
            # ポートフォリオ指標計算 (50%:50%の配分)
            portfolio_returns = 0.5 * returns1_common + 0.5 * returns2_common
            
            # 年率換算 (252営業日)
            expected_return = portfolio_returns.mean() * 252
            portfolio_risk = portfolio_returns.std() * np.sqrt(252)
            
            # 相関係数計算
            try:
                correlation = returns1_common.corr(returns2_common)
            except:
                correlation = 0.0
            
            # NaNチェック
            if pd.isna(expected_return) or pd.isna(portfolio_risk) or pd.isna(correlation):
                failed_combinations.append(f"{ticker1}×{ticker2}: NaN値が発生")
                continue
            
            # 無限大チェック
            if np.isinf(expected_return) or np.isinf(portfolio_risk) or np.isinf(correlation):
                failed_combinations.append(f"{ticker1}×{ticker2}: 無限大値が発生")
                continue
            
            # シャープレシオ（リスクフリーレート0%と仮定）
            sharpe_ratio = expected_return / portfolio_risk if portfolio_risk > 0 and not np.isnan(portfolio_risk) else 0
            
            portfolio_data.append({
                '銘柄1': get_japanese_company_name(ticker1, {}),
                '銘柄2': get_japanese_company_name(ticker2, {}),
                'ティッカー1': ticker1,
                'ティッカー2': ticker2,
                '期待リターン(年率)': expected_return,
                'リスク(年率)': portfolio_risk,
                '相関係数': correlation,
                'シャープレシオ': sharpe_ratio,
                'データ期間': f"{len(common_dates)}日"
            })
            
        except Exception as e:
            failed_combinations.append(f"{ticker1}×{ticker2}: {str(e)}")
            continue
    
    # プログレスバーを削除
    progress_bar.empty()
    
    # 結果サマリー
    success_count = len(portfolio_data)
    failure_count = len(failed_combinations)
    
    if success_count > 0:
        st.success(f"✅ 成功: {success_count}組み合わせ / 失敗: {failure_count}組み合わせ")
    else:
        st.error(f"❌ 成功: {success_count}組み合わせ / 失敗: {failure_count}組み合わせ")
    
    # 失敗詳細を表示（最大10件）
    if failed_combinations:
        with st.expander(f"⚠️ 失敗した組み合わせの詳細 ({len(failed_combinations)}件)"):
            for i, failure in enumerate(failed_combinations[:10]):
                st.text(f"{i+1}. {failure}")
            if len(failed_combinations) > 10:
                st.text(f"... 他 {len(failed_combinations) - 10}件")
    
    return pd.DataFrame(portfolio_data)

def sort_combinations(df, sort_option):
    """組み合わせデータのソート"""
    if sort_option == "シャープレシオ(降順)":
        return df.sort_values('シャープレシオ', ascending=False)
    elif sort_option == "リスク(昇順)":
        return df.sort_values('リスク(年率)', ascending=True)
    elif sort_option == "相関(昇順)":
        return df.sort_values('相関係数', ascending=True)
    elif sort_option == "期待リターン(降順)":
        return df.sort_values('期待リターン(年率)', ascending=False)
    return df

def render_simulation_interface(selected_tickers):
    """シミュレーションUI"""
    st.subheader(f"📈 {selected_tickers[0]} × {selected_tickers[1]} シミュレーション")
    
    col_sim1, col_sim2 = st.columns(2)
    
    with col_sim1:
        # 投資配分設定
        allocation_a = st.slider(
            f"{selected_tickers[0]}への投資比率(%)",
            min_value=0,
            max_value=100,
            value=50,
            step=5
        )
        allocation_b = 100 - allocation_a
        st.write(f"{selected_tickers[1]}への投資比率: {allocation_b}%")
        
        # 取引タイミング
        trading_time = st.selectbox(
            "取引タイミング:",
            ["9:00 始値", "15:00 終値"]
        )
    
    with col_sim2:
        # シミュレーション期間
        start_date = st.date_input(
            "開始日:",
            value=datetime.now() - timedelta(days=365),
            max_value=datetime.now() - timedelta(days=1)
        )
        
        end_date = st.date_input(
            "終了日:",
            value=datetime.now() - timedelta(days=1),
            max_value=datetime.now() - timedelta(days=1)
        )
    
    # シミュレーション実行
    if st.button("🚀 シミュレーション実行", type="primary", use_container_width=True):
        with st.spinner("📊 バックテストを実行中..."):
            results = run_portfolio_simulation(
                [f"{selected_tickers[0]}.T", f"{selected_tickers[1]}.T"],
                [allocation_a/100, allocation_b/100],
                start_date,
                end_date,
                trading_time == "9:00 始値"
            )
            
            if results:
                display_simulation_results(results, selected_tickers)

def run_portfolio_simulation(tickers, allocations, start_date, end_date, use_open_price):
    """ポートフォリオシミュレーション実行"""
    try:
        initial_capital = 3_000_000  # 300万円
        max_loss = 300_000  # 30万円
        min_capital = initial_capital - max_loss
        
        # データ取得
        data = {}
        for ticker in tickers:
            ticker_data = yf.download(ticker, start=start_date, end=end_date, progress=False, auto_adjust=True)
            if ticker_data.empty:
                st.error(f"❌ {ticker}のデータを取得できませんでした")
                return None
            data[ticker] = ticker_data
        
        # 共通の取引日を取得
        common_dates = None
        for ticker_data in data.values():
            if common_dates is None:
                common_dates = ticker_data.index
            else:
                common_dates = common_dates.intersection(ticker_data.index)
        
        if len(common_dates) == 0:
            st.error("❌ 共通の取引日が見つかりませんでした")
            return None
        
        # 初日の投資実行
        first_date = common_dates[0]
        portfolio = {}
        remaining_cash = 0
        
        price_column = 'Open' if use_open_price else 'Close'
        
        for i, ticker in enumerate(tickers):
            investment_amount = initial_capital * allocations[i]
            
            # MultiIndexの場合の処理
            if isinstance(data[ticker].columns, pd.MultiIndex):
                stock_price = data[ticker].iloc[:, data[ticker].columns.get_level_values(0) == price_column].iloc[0, 0]
            else:
                stock_price = data[ticker].loc[first_date, price_column]
                
            shares = int(investment_amount / stock_price)  # 切り捨て
            actual_investment = shares * stock_price
            
            portfolio[ticker] = shares
            remaining_cash += investment_amount - actual_investment
        
        # 日次資産評価
        daily_values = []
        portfolio_values = []
        
        for date in common_dates:
            total_value = remaining_cash
            
            for ticker in tickers:
                if ticker in portfolio:
                    # MultiIndexの場合の処理
                    if isinstance(data[ticker].columns, pd.MultiIndex):
                        current_price = data[ticker].iloc[:, data[ticker].columns.get_level_values(0) == 'Close'].loc[date].iloc[0]
                    else:
                        current_price = data[ticker].loc[date, 'Close']
                    total_value += portfolio[ticker] * current_price
            
            daily_values.append({
                'Date': date,
                'Portfolio_Value': total_value,
                'Return': (total_value - initial_capital) / initial_capital
            })
            
            portfolio_values.append(total_value)
            
            # 強制終了チェック
            if total_value <= min_capital:
                st.warning(f"⚠️ {date.strftime('%Y-%m-%d')}に最大損失に達したため、シミュレーション終了")
                break
        
        # 結果計算
        final_value = portfolio_values[-1]
        total_return = (final_value - initial_capital) / initial_capital
        max_value = max(portfolio_values)
        max_drawdown = (max_value - min(portfolio_values)) / max_value
        
        return {
            'daily_values': pd.DataFrame(daily_values),
            'portfolio': portfolio,
            'initial_capital': initial_capital,
            'final_value': final_value,
            'total_return': total_return,
            'max_drawdown': max_drawdown,
            'first_date': first_date,
            'price_column': price_column,
            'tickers': tickers,
            'allocations': allocations
        }
        
    except Exception as e:
        st.error(f"❌ シミュレーション実行エラー: {str(e)}")
        return None

def display_simulation_results(results, selected_tickers):
    """シミュレーション結果の表示"""
    st.markdown("---")
    st.subheader("📊 シミュレーション結果")
    
    # サマリーメトリクス
    col_metric1, col_metric2, col_metric3, col_metric4 = st.columns(4)
    
    with col_metric1:
        st.metric(
            "最終資産",
            f"¥{results['final_value']:,.0f}",
            f"¥{results['final_value'] - results['initial_capital']:+,.0f}"
        )
    
    with col_metric2:
        st.metric(
            "トータルリターン",
            f"{results['total_return']:.2%}",
            "vs 初期資金"
        )
    
    with col_metric3:
        st.metric(
            "最大ドローダウン",
            f"{results['max_drawdown']:.2%}",
            "最大下落率"
        )
    
    with col_metric4:
        # 日次のボラティリティ
        daily_returns = results['daily_values']['Return'].pct_change().dropna()
        volatility = daily_returns.std() * np.sqrt(252) if len(daily_returns) > 1 else 0
        st.metric(
            "ボラティリティ",
            f"{volatility:.2%}",
            "年率"
        )
    
    # 資産推移グラフ
    st.subheader("📈 資産推移")
    
    fig = go.Figure()
    
    # ポートフォリオ価値
    fig.add_trace(go.Scatter(
        x=results['daily_values']['Date'],
        y=results['daily_values']['Portfolio_Value'],
        mode='lines',
        name='ポートフォリオ',
        line=dict(color='blue', width=3)
    ))
    
    # 初期資金ライン
    fig.add_hline(
        y=results['initial_capital'],
        line_dash="dash",
        line_color="gray",
        annotation_text="初期資金"
    )
    
    # 強制終了ライン
    fig.add_hline(
        y=results['initial_capital'] - 300_000,
        line_dash="dash",
        line_color="red",
        annotation_text="強制終了ライン"
    )
    
    fig.update_layout(
        title="ポートフォリオ資産推移",
        xaxis_title="日付",
        yaxis_title="資産価値 (円)",
        height=500
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # 取引サマリー
    st.subheader("📋 取引サマリー")
    
    trade_data = []
    for i, ticker in enumerate(results['tickers']):
        ticker_code = ticker.replace('.T', '')
        shares = results['portfolio'][ticker]
        allocation = results['allocations'][i]
        investment = results['initial_capital'] * allocation
        
        trade_data.append({
            '銘柄コード': ticker_code,
            '企業名': get_japanese_company_name(ticker, {}),
            '購入株数': f"{shares:,}株",
            '投資配分': f"{allocation:.1%}",
            '投資額': f"¥{investment:,.0f}"
        })
    
    trade_df = pd.DataFrame(trade_data)
    st.dataframe(trade_df, use_container_width=True)

# --- メイン実行部分 ---
def main():
    """メインアプリケーション"""
    
    # ログイン状態チェック
    if not st.session_state.authenticated:
        login_page()
        return
    
    # ログアウトボタンをサイドバーに追加
    with st.sidebar:
        st.write(f"👤 ログイン中: **{st.session_state.username}**")
        
        col1, col2 = st.columns(2)
        with col1:
            if st.button("🔑 パスワード変更", type="secondary", use_container_width=True):
                st.session_state.page = 'password_change'
                st.rerun()
        with col2:
            if st.button("🚪 ログアウト", type="secondary", use_container_width=True):
                logout()
    
    # サイドバー設定
    with st.sidebar:
        st.title("📊 分析設定")
        
        # 銘柄入力
        ticker_input = st.text_input(
            "分析対象銘柄コード:", 
            value="6357",
            help="例: 6357, 4816, 2991 など"
        )
        
        # 分析実行ボタン
        if st.button("🔍 統合分析実行", use_container_width=True):
            if ticker_input:
                st.session_state.page = 'detail'
                st.session_state.selected_ticker = f"{ticker_input}.T"
                st.rerun()
        
        st.markdown("---")
        
        # ナビゲーション
        st.subheader("🧭 ナビゲーション")
        if st.button("🏠 ダッシュボード", use_container_width=True):
            st.session_state.page = 'dashboard'
            st.rerun()
        
        if st.button("📊 ポートフォリオ戦略室", use_container_width=True):
            st.session_state.page = 'portfolio_strategy'
            st.rerun()
        
        # 機能説明
        st.markdown("---")
        st.subheader("💡 機能説明")
        
        with st.expander("📈 テクニカル分析"):
            st.write("""
            - ローソク足チャート（移動平均線付き）
            - RSI指標・価格統計
            """)
        
        with st.expander("🏢 ファンダメンタル分析"):
            st.write("""
            - 財務指標推移（売上高・営業利益等）
            - 成長率・収益性分析
            """)
        
        with st.expander("🔍 株価変動要因分析"):
            st.write("""
            - 5%以上の大きな株価変動の要因分析
            - テクニカル・ファンダメンタル・業界特有要因の特定
            - 上昇・下落パターンの詳細分析
            """)
        
        with st.expander("📊 業績予想精度分析"):
            st.write("""
            対応銘柄: 三精テクノロジーズ、東映アニメーション、
            ランドネット、ワークマン、助川電気工業、鈴茂器工、
            ウェルネット、木村工機、日本電子材料、JFEシステムズ、
            テー・オー・ダブリュー
            
            - 予想vs実績の推移分析
            - 予想精度の誤差率計算
            - 企業の予想傾向分析
            """)
    
    # メインコンテンツエリア
    # ダッシュボードのデータ準備
    tickers = ['6357.T', '4816.T', '2991.T', '7564.T', '7711.T', '6405.T', 
              '2428.T', '6231.T', '6855.T', '4832.T', '4767.T']
    
    # 株価データの取得
    all_data = {}
    ticker_info_dict = {}
    fundamental_data_dict = {}
    market_indices = {}
    
    with st.spinner('📊 データを読み込み中...'):
        # 市場指標の取得（日経平均、TOPIX）
        try:
            # 日経平均（^N225）
            nikkei = yf.Ticker("^N225")
            nikkei_data = nikkei.history(period='1y')
            if not nikkei_data.empty:
                market_indices['日経平均'] = nikkei_data
                
            # TOPIX（1306.T - TOPIX連動型ETF）
            # ^TPXが利用できない場合は、TOPIX連動ETFを使用
            try:
                topix = yf.Ticker("1306.T")  # TOPIX連動型ETF
                topix_data = topix.history(period='1y')
                if not topix_data.empty:
                    market_indices['TOPIX'] = topix_data
            except:
                # 代替として別のTOPIX関連ETFを試す
                try:
                    topix = yf.Ticker("1308.T")  # TOPIX Core 30連動型ETF
                    topix_data = topix.history(period='1y')
                    if not topix_data.empty:
                        market_indices['TOPIX'] = topix_data
                except:
                    st.sidebar.info("ℹ️ TOPIX指標の取得をスキップしました")
        except Exception as e:
            st.sidebar.warning(f"⚠️ 市場指標の取得エラー: {str(e)}")
        
        # 個別株式の取得
        for ticker in tickers:
            try:
                # 株価データ
                yf_ticker = yf.Ticker(ticker)
                hist_data = yf_ticker.history(period='1y')
                
                if not hist_data.empty:
                    # テクニカル指標を追加
                    hist_data = calculate_rsi(hist_data)
                    hist_data['MA20'] = hist_data['Close'].rolling(window=20).mean()
                    hist_data['MA50'] = hist_data['Close'].rolling(window=50).mean()
                    all_data[ticker] = hist_data
                    
                    # 企業情報
                    ticker_info_dict[ticker] = yf_ticker.info
                
                # ファンダメンタルデータ（対応銘柄のみ）
                fund_file_path = f'cleaned_financials_{ticker.replace(".T", "")}.csv'
                if os.path.exists(fund_file_path):
                    try:
                        fund_data = pd.read_csv(fund_file_path, index_col=0, parse_dates=True)
                        fundamental_data_dict[ticker] = fund_data
                    except Exception as e:
                        st.sidebar.warning(f"⚠️ {ticker} のファンダメンタルデータ読み込みエラー: {str(e)}")
                        pass
                        
            except Exception as e:
                st.sidebar.error(f"❌ {ticker} のデータ取得に失敗: {str(e)}")
                continue
    
    # ページルーティング
    if st.session_state.page == 'dashboard':
        render_main_dashboard(all_data, ticker_info_dict, fundamental_data_dict, market_indices)
    
    elif st.session_state.page == 'password_change':
        password_change_page()
    
    elif st.session_state.page == 'portfolio_strategy':
        render_portfolio_strategy_page()
    
    elif st.session_state.page == 'detail' and st.session_state.selected_ticker:
        ticker = st.session_state.selected_ticker
        if ticker in all_data:
            render_detail_page(
                ticker, 
                all_data[ticker], 
                ticker_info_dict.get(ticker, {}),
                fundamental_data_dict.get(ticker)
            )
        else:
            st.error(f"❌ {ticker} のデータが見つかりません")
            if st.button("ダッシュボードに戻る"):
                st.session_state.page = 'dashboard'
                st.rerun()
    
    else:
        st.session_state.page = 'dashboard'
        render_main_dashboard(all_data, ticker_info_dict, fundamental_data_dict, market_indices)

# アプリケーション実行
if __name__ == "__main__":
    main()
else:
    main()
